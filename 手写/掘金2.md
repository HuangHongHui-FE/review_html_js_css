function fun(a,b) {
    console.log(b)
    return {
        fun: function(c) {
            return fun(c,a);
        }
    };
}
var d = fun(0); // undefined
d.fun(1); // 2 0
d.fun(2); // 2 0
d.fun(3); // 2 0

var d1 = fun(0).fun(1).fun(2).fun(3);
// 2 undefined 2 0
// 2 1
// 2 2

var d2 = fun(0).fun(1); d2.fun(2);
// 2 undefined
// 2 0
// 2 1
// 2 1

d2.fun(3); // {fun: ƒ}
```

```


深度遍历与广度
async await
js设计模式

鼠标事件坐标
offsetX, clientX, pageX, screenX

元素视图尺寸
offsetLeft, offsetTop: 当前元素到定位父节点的top方向上的距离
offsetWidth: 获取的值为    当前元素width + 左右padding + 左右border - width
clientWidth: 获取的值为    当前元素宽度 + 左右的padding
scrollWidth: 获取当前元素内容真实的宽度， 内容不超过盒子时为盒子的clientWidth

window视图的尺寸
innerWidth: 浏览器窗口可视区宽度 （不包括浏览器控制台，菜单栏，工具栏）


__proto__   protype
原型，原型链

所有对象都有一个属性 __proto__ 指向一个对象，也就是原型   对象
每个对象的原型都可以通过 constructor 找到构造函数，构造函数也可以通过 prototype 找到原型
所有函数都可以通过 __proto__ 找到 Function 对象
所有对象都可以通过 __proto__ 找到 Object 对象
对象之间通过 __proto__ 连接起来，这样称之为原型链。当前对象上不存在的属性可以通过原型链一层层往上查找，直到顶层 Object 对象，再往上就是 null 了




深拷贝

垃圾回收    /

call,apply,bind的手写

通过遍历data中的数据，将数据代理到this上      /



diff

postMessage实现跨域
    语法：window.postMessage(msg,targetOrigin)
    message：要发送的消息，部分浏览器只能处理字符串参数，所以我们在传递参数的时候需要使用JSON.stringify()方法对对象参数序列化
    targetOrigin：“目标域“，包括：协议、主机名、端口号。若指定为”*“，则表示可以传递给任意窗口，指定为”/“，则表示和当前窗口的同源窗口。

    获取postMessage传来的消息：为页面添加onmessage事件
    window.addEventListener('message',function(e) {
        
    }
    onmessage事件接受一个参数e,它是一个event对象。
    e的几个重要属性：
      1、data：postMessage传递过来的msg
      2、发送消息的窗口对象
      3、origin：发送消息窗口的源（协议+主机+端口号）



点击劫持里面的iframe是如何内嵌到第三方网页上实现点击劫持的:
    攻击者使用一个或多个透明的 iframe 覆盖在一个正常的网页上，当用户在不知情的情况下点击透明的 iframe 页面时，用户的操作已经被劫持到攻击者事先设计好的恶意按钮或链接上。攻击者既可以通过点击劫持设计一个独立的恶意网站，执行钓鱼攻击等；也可以与 XSS 和 CSRF 攻击相结合，突破传统的防御措施，提升漏洞的危害程度。

    通过XSS漏洞弹出弹框，诱导用户点击触发点击劫持，浏览器执行恶意的js代码，故此将会产生极大的危害

点击劫持的防御
    X-FRAME-OPTIONS机制， 
        DENY：浏览器会拒绝当前页面加载任何frame页面
        SAMEORIGIN：frame页面的地址只能为同源域名下的页面
        ALLOW-FROM origin：允许frame加载的页面地址



csrf攻击B站如何获取A站的cookie信息的，原理

vue双向绑定的原理，如何达到视图更新的

data不发生更新时，computed还会进行缓存操作吗？还会执行吗？       只执行一次，有缓存

服务端渲染

隐藏盒子的几种方式

高度塌陷

实现一个页面加载进度条

css reset 和 Normalize.css 有什么区别

css hask：
    不同的浏览器对应不同的内核，它们对css的解析是不一样的，这样就会导致在不同的浏览器中呈现出不一致的效果，为了给不同的浏览添加不同效果，就需要针对不同的浏览器或者不同的版本写特定的css样式，这就叫css hack。

    1. css属性前缀法   例如 IE6能识别下划线"_"和星号" * "，IE7能识别星号" * "，但不能识别下划线"_"，IE6~IE10都认识"\9"，但firefox前述三个都不能认识。
    
    2.  css选择器前缀法     例如 IE6能识别*html   .class{}，IE7能识别*+html   .class{}或者*:first-child+html .class{}。
    
    3. IE条件注释法   针对所有IE(注：IE10+已经不再支持条件注释)： IE浏览器显示的内容 ，针对IE6及以下版本： 。这类Hack不仅对CSS生效，对写在判断语句里面的所有代码都会生效。



### 伪类和伪元素的区别是什么？

概念上的区别：
- 伪类表示一种状态
- 伪元素是真的有元素。比如 ::after 是真的有元素，可以在页面上显示内容。
使用上的区别：
- 伪类：使用单冒号
- 伪元素：使用双冒号


伪类：
    a:link {color:#FF0000;} /* 未访问的链接 */
    a:visited {color:#00FF00;} /* 已访问的链接 */
    a:hover {color:#FF00FF;} /* 鼠标划过链接 */
    a:active {color:#0000FF;} /* 已选中的链接 */
    :checked	input:checked	选择所有选中的表单元素
    :disabled	input:disabled	选择所有禁用的表单元素
    :enabled	input:enabled	选择所有启用的表单元素
    :last-child   	p:last-child	选择所有p元素的最后一个子元素
    :nth-child(n)	p:nth-child(2)	选择所有 p 元素的父元素的第二个子元素
    :first-child	p:first-child	选择器匹配属于任意元素的第一个子元素的 <p> 元素


```
![image-20220228090140367](%E6%8E%98%E9%87%91%E9%9D%A2%E7%BB%8F.assets/image-20220228090140367.png)

![image-20220329084043124](%E6%8E%98%E9%87%91.assets/image-20220329084043124.png)


vue3比vue2快在哪？
    Diff算法的优化：
        Vue2 中的 虚拟DOM对比采用全量对比策略，这样的话每次渲染也就把静态dom节点做对比了。vue3中通过diff算法对比虚拟dom的时候，只会比较有动态绑定数据变化的节点，也就是有patch flag标记的。
    静态提升：
        vue2中无论节点有没有动态绑定数据，都会在render函数执行的时候重新渲染。静态的节点被提升到渲染函数外部，缓存起来，然后只会在首次的时候执行一下节点创建函数，以后每次渲染都拿外面的那个变量就行了;
    事件监听缓存：
        Vue2版本中,事件是被当做一种动态属性来监听的，但是事件监听函数，基本上是不会动态改变的；所以再进行监听是完全没有必要的。渲染函数渲染出来的对象，不再具有动态属性的标志,不是动态的，自然也不会生成监听了。
    tree-shaking
        需要什么就 import 什么，而不是每个组件都有props,
    vite
    ts
    proxy替换了之前的defineProterty


get和post的区别:
    1、url可见性：
        get，参数url可见；
        post，url参数不可见
    2、数据传输上：get，通过拼接url进行传递参数; post，通过body体传输参数;
    4、后退页面的反应   :post请求页面后退时，会重新提交请求
    3. get一般传输数据大小不超过2k-4k（根据浏览器不同，限制不一样，但相差不大）post请求传输数据的大小可以无限大。
    7、数据包
        GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。


object.defineProperty
const newObj = new Proxy(obj, {
    get: function(target, key, receiver) {
        console.log(`getting ${key}!`);
        return Reflect.get(target, key, receiver); // Reflect.get 和 Reflect.set 可以理解为类继承里的super，即调用原来的方法
    },
    set: function(target, key, value, receiver) {
        console.log(target, key, value, receiver, '对象劫持');
        if (key === "text") {
            inp.value = value;
            title.innerHTML = value;
        }
        return Reflect.set(target, key, value, receiver);
    }
});


Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与proxy handlers (en-US)的方法相同。Reflect不是一个函数对象，因此它是不可构造的。




vue数据变化UI不刷新
    使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上：
    setOptionVal: function (index, val) {
        let tempVal = this.SubjectListData[index]
        tempVal.optionIdStringResult = val
        this.$set(this.SubjectListData, index, tempVal)
    }



数据库外连接，内连接区别
    inner join  on ：对于左表的每一条记录和右表作乘积，如果满足on条件则加入结果集，最终的记录数>=0
    left    join  on ：对于左表的每一条记录和右表作乘积，如果不存在满足on条件的记录，则添加一条记录（需要返回的右表列以null表示），最终的记录数>=左表的记录数
    right  join on ： 对于右表的每一条记录和左表作乘积，如果不存在满足on条件的记录，则添加一条记录（需要返回的左表列以null表示），最终的记录数>=右表的记录数




echarts原理
    1、ECharts 是一个轻量级的 javascript 图形库，纯 js 实现，MVC 封装，数据驱动。
    2、Svg 和 Canvas 是两个可以选择的类库之一，其中 svg 交互性更好，性能较弱，不适用于移动端，在绘制数万个点时会崩溃。而 canvas 的渲染速度和性能更好，echarts 在 canvas 上构建一层 MVC层，使得它可以像 svg 一样交互。
    3、ECharts 的特点：重要性和优先级依次递减，设计效果直观、生动，能够交互，可个性化定制。

    4、ECharts 总体结构是基于 MVC 架构的，各部分的主要作用是：
    Storage(M)：模型层，实现图形数据的CURD（增删改查）管理；
    Painter(V)：  视图层，实现canvas 元素的生命周期管理，即：视图渲染、更新控制、绘图；
    Handler(C)：控制层，事件交互处理，实现完整的dom事件模拟封装。
    
    Storage 是一个类似数据的仓库，提供各种数据的读、写、改、删等操作。Painter 持有 Storage 对象，即：Painter 读取 Storage 进行绘图。Handler持有了Storage 对象和 Painter 对象，控制层对模型层有CURD关系，即：Handler 通过访问 Storage 对象提供的数据增删改查操作，实现事件交互处理所需的数据部分；控制层与视图层存在 call 关系，即：Handler 通过访问 Painter 对象提供的视图操作，实现事件交互处理的视图部分




vuex的单向数据流
    单向数据流指只能从一个方向来修改状态。多个组件会共享状态时，共享状态和组件间（兄弟组件）通信变的不容易。我们把共享状态抽取出来。
    组件中触发 Action，Action 提交 Mutations，Mutations 修改 State。 组件根据 State 或 Getters 来渲染页面。
    只有通过mutations来修改state


canvas与svg
    https://www.cnblogs.com/yanghuiting/p/10902001.html



hr面：
1.自我介绍
2.想要的工作性质
3.优点缺点，缺点怎么提高
4.怎么学习的，为什么走前端
5.这段时间的收获及成长
6 .还有没有其他的面试
7.如果bat都发offer,怎么选
8.最近看什么书
9.有什么想问的



web移动端安卓和ios的一些兼容问题:
    https://www.cnblogs.com/sisxxw/p/12502773.html



option请求中是否见到过
复杂跨域请求，首先会发送一个options请求来决定真正的请求是否足够安全。
那么如果区分简单请求以及复杂请求就比较关键了，下面是几个关键的点：
method
    GET
    POST
    HEAD
    headers
Accept
    Accept-Language
    Content-Language
    Content-Type
其中 content-type 值只包括
    application/x-www-form-urlencoded
    multipart/form-data
    text/plain



为什么 CORS 需要在跨域请求前进行预校验 (Preflight)
    预检验请求是一个不携带任何具体参数的 OPTIONS 请求
    采用 CORS 的服务器会正确的根据请求头来判断是否接受该跨域请求，并返回相应的响应告知浏览器
    未采用的服务器接受到请求也会正常处理
    但是返回的响应中不会正确的包含 Access-Control-Allow-* 等响应头
    浏览器接收到预检验请求的响应后会根据响应头来判断是否支持跨域
    只有当响应头满足 CORS 的相关设置才会继续发送正式的跨域请求

    在实际调用接口之前，会首先发出一个options请求，检测服务端是否支持真实的请求进行跨域的请求。真实请求在options请求中，通过request-header将 Access-Control-Request-Headers与Access-Control-Request-Method发送给后台，另外浏览器会自行加上一个Origin请求地址。服务端在接收到预检请求后，根据资源权限配置，在response-header头部加入access-control-allow-headers（允许跨域请求的请求头）、access-control-allow-methods（允许跨域请求的请求方式）、access-control-allow-origin（允许跨域请求的域）。另外，服务端还可以通过Access-Control-Max-Age来设置一定时间内无须再进行预检请求，直接用之前的预检请求的协商结果即可。浏览器再根据服务端返回的信息，进行决定是否再进行真实的跨域请求。
    
    只要是带自定义header的跨域请求，在发送真实请求前都会先发送OPTIONS请求，浏览器根据OPTIONS请求返回的结果来决定是否继续发送真实的请求进行跨域资源访问。所以复杂请求肯定会两次请求服务端。

options请求如何避免:
    1：使用代理，避开跨域。
    2：将复杂跨域请求更改为简单跨域请求。
    3：不使用带自定义配置的header头部。



CommonJS.js
es6.js



vue的loader
    简单的说，他就是基于webpack的一个的loader，解析和转换 .vue 文件，提取出其中的逻辑代码 script、样式代码 style、以及 HTML 模版 template，再分别把它们交给对应的 Loader 去处理，核心的作用，就是提取，划重点。

    selector–将.vue文件解析拆分成一个parts对象，其中分别包含style、script、template
    style-compiler–解析style部分
    template-compiler 解析template部分
    babel-loader-- 解析script部分，并转换为浏览器能识别的普通js
    
    允许为 Vue 组件的每个部分使用其它的 webpack loader
    使用 webpack loader 将 <style> 和 <template> 中引用的资源当作模块依赖来处理
    
    至于什么是webpack的loader，其实就是用来打包、转译js或者css文件，简单的说就是把你写的代码转换成浏览器能识别的，还有一些打包、压缩的功能等。



vue请求数据放在
    建议放在created里
    created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。
    mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。
    如果在mounted钩子函数中请求数据可能导致页面闪屏问题
    其实就是加载时机问题，放在created里会比mounted触发早一点，如果在页面挂载完之前请求完成的话就不会看到闪屏了



rem根字体大小设置
    <!DOCTYPE html>
    <html>
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta charset="utf-8">
        <title></title>
        <script>
            var c=()=>{
                let w = document.documentElement.clientWidth; /*获取设备的宽度*/
                let n = (20 * (w / 320) > 40 ? 40 + "px": (20*(w/320) + "px"));
                // console.log(n)
                // 注意这里
                document.documentElement.style.fontSize=n
            }
            window.addEventListener("load",c)
            window.addEventListener("resize", c)
        </script>
        <style>
            html{
                font-size: 200px;
            }
            div{
                font-size: 2rem;
            }
        </style>
    </head>
    <body>
        <div>123</div>
    </body>
    </html>



websocket设置
    事件：
    server.on('open', handleOpen);
    server.on('close', handleClose);
    server.on('error', handleError);
    server.on('connection', handleConnection);
    所有的连接者:
    server.clients
    连接者.send()即可

    有信息来的话就会触发on,
    ws.on('message', handleMessage);
    
    function handleMessage (msg) {
        const msg01 = JSON.parse(msg.toString())
        msg01.user = AES.aesDecrypt(msg01.user)
        server.clients.forEach((c) => {
            c.send(JSON.stringify(msg01));
        })
    }



2、组合式 API
    Options API 的特点是在对应的属性中编写对应的功能模块
    比如：在 methods 中定义方法，在 computed 中定义计算属性
    缺点是：
    实现某一个功能时，该功能对应的代码逻辑会被 拆分 到各个属性中
    然而，当我们的组件变得更大、更复杂的时候，我们需要实现的功能也就越多
    每一个功能对应的代码逻辑都被拆的很分散，代码碎片化
    这是 不方便 我们的去 理解和维护 这个组件的
    因此，在 Vue 组件中，我们可以在 setup 中使用组合式 API，来解决上述问题
    注意：在 setup 中，我们应该避免使用 this




单文件组件与非单文件组件


// 监听hash变化
    // 每次点击路由，current都会变化，但是render却不会再次执行
    window.addEventListener('hashchange', () => {
        this.current = window.location.hash.slice(1)  // 截取到#号后面的部分
    })







rpx的原理：
    小程序编译后，rpx会做一次px换算。换算是以375个物理像素为基准，也就是在一个宽度为375物理像素的屏幕下，1rpx = 1px。

    举个例子：iPhone6屏幕宽度为375px，共750个物理像素，那么1rpx = 375 / 750 px = 0.5px。


TCP 怎么保证传输的可靠性？如果ACK 1 2 3 4 5中 4 不见了怎么办？
    队头阻塞，面试官：一定会阻塞吗？
    超时重传，面试官：还有吗？等的话要等多久？


浏览器URL的解析全过程，越详细越好

webpack配置反向代理
    devServer: {
        contentBase: path.resolve(__dirname, "../dev"),
        compress: true,
        port: 9000,  //本身的端口号
        host: 'localhost',
        proxy: {
            '/api': {
                target: 'http://localhost:3000',  //代理到的地址
                changeOrigin: true
            }
        }
    }

nginx配置反向代理：
    ![image-20220306133705095](%E6%8E%98%E9%87%91.assets/image-20220306133705095.png)
    在serve中配置：
        server_name: 
            配置为nginx的地址
        listen:
            配置端口

        location字段  / ：
            配置proxy_pass: 为node中的路径





超时重传的时间：
    在Linux中（BSD Unix和Windows下也是这样）超时以500ms为一个单位进行控制，每次判定超时重发的超时时间都是500ms的整数倍。重发一次后，仍未响应，那么等待2*500ms的时间后，再次重传。等待4*500ms的时间继续重传。以一个指数的形式增长。累计到一定的重传次数，TCP就认为网络或者对端出现异常，强制关闭连接。


tcp的拥塞控制
    TCP传输的过程中，发送端如果刚开始就发送大量的数据，网络可能在开始的时候就很拥堵。
    所以TCP引入了慢启动的机制，在开始发送数据时，先发送少量的数据探路。这时候就引入一个叫做拥塞窗口。发送刚开始定义拥塞窗口为 1，每次收到ACK应答，拥塞窗口加 1。在发送数据之前，首先将拥塞窗口与接收端反馈的窗口大小比对，取较小的值作为实际发送的窗口。

    拥塞窗口的增长是指数级别的。慢启动的机制只是说明在开始的时候发送的少，发送的慢，但是增长的速度是非常快的。为了控制拥塞窗口的增长，设置一个拥塞窗口的阈值，当拥塞窗口大小超过阈值时，不能再按照指数来增长，而是线性的增长。在慢启动开始的时候，慢启动的阈值等于窗口的最大值，一旦造成网络拥塞，发生超时重传时，慢启动的阈值会为原来的一半（这里的原来指的是发生网络拥塞时拥塞窗口的大小），同时拥塞窗口重置为 1。

确认应答与序列号
    序列号：TCP传输时将每个字节的数据都进行了编号，这就是序列号。
    确认应答：TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文。这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。




先来分析一下 webpack Plugin 的工作原理

    读取配置的过程中会先执行 new HelloPlugin(options) 初始化一个 HelloPlugin 获得其实例。
    初始化 compiler 对象后调用 HelloPlugin.apply(compiler) 给插件实例传入 compiler 对象。
    插件实例在获取到 compiler 对象后，就可以通过compiler.plugin(事件名称, 回调函数) 监听到 Webpack 广播出来的事件。
    并且可以通过 compiler 对象去操作 Webpack。


![WebPack 编译流程图](https://segmentfault.com/img/remote/1460000023016350)




怎么能不使用缓存：
    cache-control:  no-store;


js与css加载顺序



浏览器缓存的问题
<html lang="en">
    <head>
        <title>test cache</title>
        <link rel="stylesheet" href="./index.css">
        <link rel="stylesheet" href="./index.css">
        <script src="./index.js"></script>
        <script src="./index.js"></script>
        <img src="./index.png">
        <img src="./index.png">
    </head>
<body>
    hello
</body>
</html>



1.这个index.html文件中，不设置任何缓存相关的策略，每种静态资源会请求几次？
2.如果给存放三种资源的服务器响应头加上Cache-Control:no-cache，这三种资源又各自会被请求几次？
3.那如果把no-cache改成no-store，会请求几次？
4.把no-cache改成max-age，又会有什么变化？
我们先不着急看答案，先看看原理分析，一步步分析出答案。

1.不设置任何缓存策略的情况下，请求只有一次。这是浏览器本身做的优化，在解析html文件时，如果监测到两个资源的地址相同，那么只会请求一次。
2.设置Cache-Control是no-cache，也是相同资源只有一次请求，no-cache并不是一定没有缓存，而是无法命中强缓存，但是还可以继续查找是否能命中协商缓存。
3.改成no-store之后，请求就有两次了，这也正好验证了no-store和no-cache的区别，no-store是绝对不走缓存，每次请求都去服务器请求新资源。
4.改成max-age，这个值设置为一年，请求也只会走一次，而且在浏览器当前TAB刷新页面，会发现Network中Size一栏不是具体的文件大小，而是from cache，这是因为已经命中了浏览器的缓存策略，所以再次缓存时，是去缓存中取资源。


1.不经常变化的资源，比如打包出来的第三方库JS，给这类资源设置一个较长的缓存周期，比如一年

Cache-Control: max-age=31536000
设置了这个字段后，就命中了强缓存策略，那么如果在一年内我们修改了这个文件，如何让用户端能够强制请求最新资源呢？

答案就是哈希，在webpack打包时给这类资源加上contentHash，一旦资源内容有更新，打包出来的资源的哈希值也会更新，用户端去加载资源时，去缓存中找不到符合这个哈希值版本的资源文件，自然会去服务端请求最新的资源。

2.经常变化的资源，比如模板文件html，这类文件的请求URL通常不会变化，但是内容会经常变化，因为每次项目更新，插入到html文件中的js或者css可能有更新。

Cache-Control: no-cache
协商缓存响应头设置成no-cache，配合协商缓存一起使用，浏览器每次都会去服务器核对资源有没有更新，如果资源没有更新，那么会返回一个304的状态码，不会返回真实的响应体，这种形式相比于命中强缓存，虽然无法节省那次网络请求，但是如果命中了协商缓存，会节省返回的响应体体积，也算是性能优化的一种。




transform 和 transition



点击后让元素飞入指定位置


document.documentElement.getBoundingClientRect().top   // 方法返回元素的大小及其相对于视口的位置。
document.documentElement.scrollHeight      
document.documentElement.clientHeight      

window.scrollTop + window.clientHeight >= img.offsetTop
页可见区域宽： document.body.clientWidth;
网页可见区域高： document.body.clientHeight;


window.innerHeight;
网页可见区域宽： document.body.offsetWidth   (包括边线的宽);
网页可见区域高： document.body.offsetHeight (包括边线的宽);
网页正文全文宽： document.body.scrollWidth;
网页正文全文高： document.body.scrollHeight;
网页被卷去的高： document.body.scrollTop;
网页被卷去的左： document.body.scrollLeft;
网页正文部分上： window.screenTop;
网页正文部分左： window.screenLeft;
屏幕分辨率的高： window.screen.height;
屏幕分辨率的宽： window.screen.width;
屏幕可用工作区高度： window.screen.availHeight





小程序原理：
    webview 和 appService两个线程相互不干扰
    两个线程是通过系统层的 JSBridage 来通信的，逻辑层把数据变化通知到视图层，触发视图层页面更新，视图层把触发的事件通知到逻辑层进行业务处理。


小程序实现下拉刷新：
    首先在全局 config 中的 window配置 enablePullDownRefresh
    ，在 Page 中定义onPullDownRefresh 钩子函数,到达下拉刷新条件后，该钩子函数执行，发起请求方法
    请求返回后，调用wx.stopPullDownRefresh停止下拉刷新


小程序视图渲染结束回调？
使用setData(data, callback)，在callback回调方法中添加后续操作代码


wx.navigateTo()：保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面
wx.redirectTo()：关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面
wx.switchTab()：跳转到 abBar 页面，并关闭其他所有非 tabBar 页面



webview中的页面怎么跳回小程序中？
    首先要引入最新版的jweixin-x.x.x.js，然后
    wx.miniProgram.navigateTo({
        url: '/pages/login/login'+'$params'
    })

    wx.miniProgram.switchTab({
        url: '/pages/index/index'
    })
    默认跳转到tab不会重新加载数据：
    需要：
    success: function (e) {
        var page = getCurrentPages().pop();
        if (page == undefined || page == null) return;
        page.onLoad();
    }



101状态码：
    客户端可使用常用的协议（如HTTP / 1.1）发起请求，请求说明需要切换到HTTP / 2或甚至到WebSocket。
    websocket的话：
        首先需要客户端发起一次普通HTTP请求。也就是说，WebSocket的建立是依赖HTTP的。
        报文头部：
        GET ws://websocket.example.com/ HTTP/1.1
        Host: websocket.example.com
        Upgrade: websocket
        Connection: Upgrade
        Origin: http://example.com
        Sec-WebSocket-Key:pAloKxsGSHtpIHrJdWLvzQ==
        Sec-WebSocket-Version:13

        HTTP头部字段Upgrade: websocket和Connection: Upgrade非常重要，告诉服务器通信协议将发生改变，转为WebSocket协议。支持WebSocket的服务器端在确认以上请求后，应返回状态码为101


301 永久重定向：会缓存        访问的地址的资源被永久移除了，以后都不应该访问这个地址
302 临时重定向：不会缓存     一般是访问某个网站的资源需要权限时，会需要用户去登录，跳转到登录页面之后登录之后，还可以继续访问。
400 请求错误，参数什么的
403 服务器禁止访问
500 服务器端错误
503 服务器繁忙



SYN Flood 攻击原理
    SYN Flood 属于典型的 DoS/DDoS 攻击。其攻击的原理很简单，就是用客户端在短时间内伪造大量不存在的 IP 地址，并向服务端疯狂发送SYN。对于服务端而言，会产生两个危险的后果:
    处理大量的SYN包并返回对应ACK, 势必有大量连接处于SYN_RCVD状态，从而占满整个半连接队列，无法处理正常的请求。
    由于是不存在的 IP，服务端长时间收不到客户端的ACK，会导致服务端不断重发数据，直到耗尽服务端的资源。



源端口、目标端口
    如何标识唯一标识一个连接？答案是 TCP 连接的四元组——源 IP、源端口、目标 IP 和目标端口。
    那 TCP 报文怎么没有源 IP 和目标 IP 呢？这是因为在 IP 层就已经处理了 IP 。TCP 只需要记录两者的端口即可。


序列号：
    本报文段第一个字节的序列号。
序列号在 TCP 通信的过程中有两个作用:
    在 SYN 报文中交换彼此的初始序列号。
    保证数据包按正确的顺序组装。


确认号
    ACK(Acknowledgment number)。用来告知对方下一个期望接收的序列号，小于ACK的所有字节已经全部收到。

说说 TCP 快速打开的原理(TFO)：
    TFO 流程：
    首轮三次握手：
        首先客户端发送SYN给服务端，服务端接收到。
        现在服务端不是立刻回复 SYN + ACK，而是通过计算得到一个SYN Cookie, 将这个Cookie放到 TCP 报文的 Fast Open选项中，然后才给客户端返回。
    客户端拿到这个 Cookie 的值缓存下来。后面正常完成三次握手。
    首轮三次握手就是这样的流程。而后面的三次握手就不一样啦！
    后面的三次握手：
        在后面的三次握手中，客户端会将之前缓存的 Cookie、SYN 和HTTP请求发送给服务端，服务端验证了 Cookie 的合法性，如果是合法的，那么就正常返回SYN + ACK。
        重点来了，现在服务端能向客户端发 HTTP 响应了！这是最显著的改变，三次握手还没建立，仅仅验证了 Cookie 的合法性，就可以返回 HTTP 响应了。
        当然，客户端的ACK还得正常传过来，不然怎么叫三次握手嘛。

![image-20220308212423148](%E6%8E%98%E9%87%91.assets/image-20220308212423148.png)

        客户端最后握手的 ACK 不一定要等到服务端的 HTTP 响应到达才发送，两个过程没有任何关系。


TCP 的时间戳主要解决两大问题:
    计算往返时延 RTT：就可以根据往返时延来控制收发的速度。
    防止序列号的回绕问题：每次发包都是将当时的内核时间记录在报文中，那么两次发包序列号即使相同，时间戳也不可能相同，这样就能够区分开两个数据包了。


TCP 的超时重传时间是如何计算的？：
    TCP 具有超时重传机制，即间隔一段时间没有等到数据包的回复时，重传这个数据包。时间有两种方法计算，用了不同的算法。


TCP 的流量控制？


Tcp的滑动窗口：
    在 TCP 链接中，对于发送端和接收端而言，TCP 需要把发送的数据放到发送缓存区, 将接收的数据放到接收缓存区。而经常会存在发送端发送过多，而接收端无法消化的情况，所以就需要流量控制，就是在通过接收缓存区的大小，控制发送端的发送。如果对方的接收缓存区满了，就不能再继续发送了。而这种流量控制的过程就需要在发送端维护一个发送窗口，在接收端维持一个接收窗口。


TCP 的拥塞控制？
    慢启动：
        首先，三次握手，双方宣告自己的接收窗口大小
        双方初始化自己的拥塞窗口(cwnd)大小
        在开始传输的一段时间，发送端每收到一个 ACK，拥塞窗口大小加 1，也就是说，每经过一个 （往返时延）RTT，（拥塞窗口）cwnd 翻倍。如果说初始窗口为 10，那么第一轮 10 个报文传完且发送端收到 ACK 后，（拥塞窗口）cwnd 变为 20，第二轮变为 40，第三轮变为 80，依次类推。它的阈值叫做慢启动阈值，当 cwnd 到达这个阈值之后。
    拥塞避免
        线性增加
    快速重传
        在 TCP 传输的过程中，如果发生了丢包，即接收端发现数据段不是按序到达的时候，接收端的处理是重复发送之前的 ACK。
        比如第 5 个包丢了，即使第 6、7 个包到达的接收端，接收端也一律返回第 4 个包的 ACK。当发送端收到 3 个重复的 ACK 时，意识到丢包了，于是马上进行重传。
    快速恢复
        发送端收到三次重复 ACK 之后，发现丢包，觉得现在的网络已经有些拥塞了，自己会进入快速恢复阶段。
        在这个阶段，发送端如下改变：
            拥塞阈值降低为 cwnd 的一半
            cwnd 的大小变为拥塞阈值
            cwnd 线性增加
    主要靠对拥塞窗口和慢启动阈值的控制
    拥塞窗口： 目前自己还能传输的数据量大小。
    接收窗口(rwnd)是接收端给的限制，拥塞窗口(cwnd)是发送端的限制，取这两个窗口的最小值来限制发送窗口的大小。



fetch与ajax:

    fetch常见坑：
        Fetch 请求默认是不带 cookie 的，需要设置 fetch(url, {credentials:'include'})
        服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。



OSI七层模型和TCP/IP四层模型
    应用层
    表示层
    会话层
    传输层
    网络层
    数据链路层
    物理层

TCP/IP 四层概念：
    应用层：应用层、表示层、会话层：HTTP
    传输层：传输层：TCP/UDP
    网络层：网络层：IP
    数据链路层：数据链路层、物理层


文档模式数据库的设计：
    一般简单直接内嵌，数据小，一对一，一对多
    多对多则考虑新建个表引用


数据库索引：
    创建索引可以大大提高系统的性能。第一，保证数据库表中数据的唯一性。第二，可以大大加快数据的检索速度。第三，可以加速表和表之间的连接。第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。

    增加索引也有许多不利的方面。第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。



不适合建索引的字段：
    频繁更新的字段，表数据比较少的不需要建索引，唯一性太差的不能建索引。



webpack热更新原理：
    webpack构建打包时，控制台会输出hash值以及json,js文件，hash是每一次编译生成的文件的标识，用来下次文件热更新请求的前缀。



webpack处理图片的loader:
    url-loader：
        其实最重要的就是他的这几个参数：limit、name、outputPath、publicPath
        limit：文件大小小于limit参数，url-loader将会把文件转为DataURL；文件大小大于limit，url-loader会调用 file-loader进行处理，参数也会直接传给file-loader。
        name：输出的文件名规则
        outputPath：表示输出文件路径前缀。图片经过url-loader打包都会打包到指定的输出文件夹下。但是我们可以指定图片在输出文件夹下的路径。比如outputPath=img/，图片被打包时，就会在输出文件夹下新建（如果没有）一个名为img的文件夹，把图片放到里面。
        publicPath：表示打包文件中引用文件的路径前缀，如果你的图片存放在CDN上，那么你上线时可以加上这个参数，值为CDN地址，这样就可以让项目上线后的资源引用路径指向CDN了。
    file-loader:
        进行options配置：打包后的图片名称与输出


Authorization:  存放token;      rsa : 非对称加密       AES: 对称加密



低代码相关：
    微搭应用市场，餐饮电商小程序，小程序以及管理后台进行小程序的管理。
    用户权限，数据源管理，组件库管理。


Serverless：
    Serverless的全称是Serverless computing无服务器运算，又被称为函数即服务（Function-as-a-Service，缩写为 FaaS），是云计算的一种模型。以平台即服务（PaaS）为基础，无服务器运算提供一个微型的架构，终端客户不需要部署、配置或管理服务器服务，代码运行所需要的服务器服务皆由云端平台来提供。Serverless是一种构建和管理基于微服务架构的技术，允许开发者在服务部署级别而不是服务器部署级别来管理应用部署，你甚至可以管理某个具体功能或端口的部署，以便让开发者快速迭代，更快速地开发软件。


nodejs实现高并发：
    采用非阻塞，异步编程
    当遇到非常耗时的IO操作时，采用非阻塞的方式，继续执行后面的代码，并且进入事件循环，当IO操作完成时，程序会被通知IO操作已经完成。运用JavaScript的回调函数来实现。
    node.js单线程只是一个js主线程，本质上的异步操作还是由线程池完成的，node将所有的阻塞操作都交给了内部的线程池去实现，本身只负责不断的往返调度，并没有进行真正的I/O操作，从而实现异步非阻塞I/O



nodejs模块查找机制：
    优先从缓存加载，再从核心模块，然后路径形式的文件模块，最后才是第三模块
    node_modules/xxx/
    node_modules/xxx/package.json
    node_modules/xxx/package.json main
    如果没有找到main 就查找目录下的 index 文件 （index文件是个备胎）
    如果以上条件都不成立就会往上级目录查找node_modules文件夹
    如果直到当前路径根目录还没查找到的话，最后报错：




js进制转十进制:
    var num = 1100100;
    console.log(parseInt(num,2));



uglifyjs-webpack-plugin：
    从 webpack 4+ 开始，生产环境下 webpack 会自动为您优化和减少捆绑包的大小，它使用的优化技术是 Tree-Shaking。本质上，它是一种用于删除未使用代码的优化技术，通过分析静态的 ES 模块，来移除未使用的代码。
    // webpack.config.js
    const Uglify = require("uglifyjs-webpack-plugin")
    module.exports = {
        optimization {
            minimize : true,
            minimizer : [
                new Uglify({
                    cache : true,
                    test: /\.js(\?.*)?$/i,
                })
            ]
        } 
    }
    通过在 optimization 对象中添加一个 minimizer 数组字段来使用其他首选缩小器



浏览器的组成：
    界面控件， 浏览器引擎， 渲染引擎， js解释器， 数据存储持久层， 网络， UI后端。



vue代码风格：
    项目名：
        全部采用小写方式， 以短横线分隔。例：my-project-name。
    图像文件名
        全部采用小写方式， 优先选择单个单词命名，多个单词命名以下划线分隔。
    单文件组件名：
        MyComponent.vue， 单词大写开头。
    组件名应该始终是多个单词：大驼峰
        export default {
            name: 'ToDoList',
            // ...
        }
    路由名字：
        // good
        {
            path: '/user-info', // 能解析成 user info
            name: 'UserInfo',
            component: UserInfo,
            meta: {
                title: ' - 用户',
                desc: ''
            }
        },

    模板中组件：
        <!-- 在单文件组件和字符串模板中 --> 
        <MyComponent/>
    
        <!-- 在 DOM 模板中 --> 
        <my-component></my-component>
    
    变量： 
        小驼峰
        // good
        let tableTitle = "LoginTable"
        let mySchool = "我的学校"
    props:
        Props 定义应该尽量详细。
    代码结构：
        <script>
            import DemoComponent from '../components/DemoComponent'
    
            export default {
                name: 'MyComponent',
                components: {
                    DemoComponent
                },
                mixins: [],
                props: {},
                data () {
                    return {}
                },
                computed: {},
                watch: {}
                created () {},
                mounted () {},
                destroyed () {},
                methods: {},
            }
        </script>
    
    v-for 设置键值


axios设置超时时间：
<!-- 全局 -->
    axios.defaults.timeout = 30000;

<!-- 单个请求 -->
    axios.post(url, postInfo,{timeout:300000})
    .then((resp: any) => {
        console.log(resp.data);
    })
    .catch((error: any) => {
        console.error(error);
    })


节点创建型api
    createElement
    createTextNode
    cloneNode
    createDocumentFragment
创建型API总结
页面修改型API
    appendChild
    insertBefore
    removeChild
    replaceChild
页面修改型API总结
节点查询型API
    document.getElementById
    document.getElementsByTagName
    document.getElementsByName
    document.getElementsByClassName
    document.querySelector和document.querySelectorAll
节点关系型api
    父关系型api
    兄弟关系型api
    子关系型api
元素属性型api
    setAttribute
    getAttribute
元素样式型api
直接修改元素的样式
动态添加样式规则
    Element.getBoundingClientRect() 方法返回元素的大小及其相对于视口的位置。



XHTML:
    XHTML 元素必须合理嵌套
    XHTML 元素必须有关闭标签
    空元素必须包含关闭标签
    属性名称必须是小写
    属性值必须有引号
    不允许属性简写



Set，Map区别:




浏览器中的线程：
    1.GUI渲染线程
        负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。
        当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行
        注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。
    2.JS引擎线程
        也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）
        JS引擎线程负责解析Javascript脚本，运行代码。
        JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序
        同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。
    3.事件触发线程
        归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）
        当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中
        当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理
        注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）
    4.定时触发器线程
        传说中的setInterval与setTimeout所在线程
        浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）
        因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）
        注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。
    5.异步http请求线程
        在XMLHttpRequest在连接后是通过浏览器新开一个线程请求
        将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。





高度塌陷：
    文档流中，父元素的高度默认是被子元素撑开的，也就是子元素多高，父元素就多高。
    但是当为子元素设置浮动以后，子元素会完全脱离文档流，此时将会导致子元素无法撑起父元素的高度，导致父元素的高度塌陷。
    
    解决方法： 父元素设置 overflow: auto 或者 overflow: hidden
            给父元素加一个 after 伪类
                .container::after{
                    content:'';
                    clear:both;
                    display:block;
                    visibility:hidden;
                    height:0; 
                }



css布局：
    flex布局， float布局， rem响应式布局， position来进行布局，百分比布局




严格模式下的限制：
    变量必须声明后再使用
    不能对只读属性赋值，否则报错
    不能使用前缀0表示八进制数，否则报错
    禁止this指向全局对象
    增加了保留字（比如protected、static和interface）


10.有哪些排序算法，复杂度如何，说一说逻辑


字符串拼接方法：
    +
    concat
    splice
    split     join



beforeMount：
    将HTML解析生成AST节点，再根据AST节点动态生成渲染函数。相关render函数首次被调用
    render函数最终返回的是虚拟节点

    既然异步函数并不会阻塞vue生命周期整个进程，那么在哪个阶段请求都可以。减少空白页面时间，建议就放在created阶段了，毕竟越早获取数据，在mounted实例挂载的时候渲染也就越及时。
    当然即使是这种情况下，也不排除会触发updated生命钩子(data有默认值且已渲染，之后数据被更新)，从而导致虚拟dom的重新渲染。


str = "abcdefg"
str.substr(2,3)   // 'cde'
str.substring(2,6)  // 'cdef'
str.substring(3, -1)  // 'abc'



vue常见指令：
    v-text， v-show, v-if, v-for, v-else, v-bind, v-model, v-once;


如果有大量的数据计算，怎么让js实现异步（不是promise这种微任务），实现真正的异步
    Web Workers:
        web worker 是运行在后台的 JavaScript，不会影响页面的性能。
        重要的部分是 postMessage() 方法 - 它用于向 HTML 页面传回一段消息。



防抖中，settimeout可能会被阻塞，一直无法执行，该怎么办


http简历连接的过程



IntersectionObserver:
    主要作用是监测元素的可见性变化。
    元素的可见比例
    监听特定元素，每次调用都会重新添加一个元素的监听

    移除元素监听
        observerInstance.disconnect()
    停止观察特定元素
        observerInstance.unobserver()


transform的使用:
    transform
        translate(x,y)
        translate3d(x,y,z)
        matrix(n,n,n,n,n,n)
        scale(x,y)
        rotate(45deg);
    transform-origin 属性允许您改变被转换元素的位置。
        transform-origin:20% 40%;






set内容不可重复的原理：
    add时：实际执行的是 map 的方法，并且我们添加的对象是 map 中的 key因为map中的key是不允许重复的，所以set中的元素不能重复。


=== 与 ==
    1、===：称为等同符，类型和值都相同返回true；

    2、==：称为等值符，当等号两边的类型相同时，直接比较值是否相等，若类型不相同，则先转化为类型相同的值，再进行比较；
    
    类型转换规则：1）如果等号两边是boolean、string、number三者中任意两者进行比较时，优先转换为数字进行比较。
    
    注意：NaN==NaN  //false，NaN和所有值包括自己都不相等。



for in 和 for of 的区别：
    for … of是作为ES6新增的遍历方式
    or … of循环的原理其实也是利用了遍历对象内部的iterator接口
    for … of遍历数组获取的是对象的键值,for … in 获取的是数组对象的键名
    for-in用来循环对象中的属性，但是通过for-in循环输出的属性名的顺序是不可测的。
    for-in会遍历原型链上的属性



async和defer:




requestAnimationFrame 比起 setTimeout、setInterval的优势主要有两点：
    1、requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。
    2、在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的的cpu，gpu和内存使用量。


阻止浏览器的默认行为：
    if (event.preventDefault) {  
​	    event.preventDefault();  
​    } else {  
​       event.returnValue = false;  
​    }



3种定义vue全局组件的方式：
    1. extend
        //第一步：使用 Vue.extend 定义组件
        var myAccount = Vue.extend({
            template: '<div><h2>登录页面</h2> <h3>注册页面</h3></div>' // 通过 template 属性，指定了组件要展示的HTML结构。template 是 Vue 中的关键字，不能改。
        });
        //第二步：使用 Vue.component 注册组件
        // Vue.component('组件的名称', 创建出来的组件模板对象)
        Vue.component('account', myAccount); //第一个参数是组件的名称（标签名），第二个参数是模板对象
        使用的时候：<account> </account>

    2. vue.template
        //定义、注册组件：第一个参数是组件的名称（标签名），第二个参数是组件的定义
        Vue.component('account', {
            template: '<div><h2>登录页面</h2> <h3>注册页面</h3></div>'   // template 是 Vue 中的关键字，不能改。
        });
        使用的时候：<account> </account>
    
    3. 在template里定义好模板，
        <!-- 定义模板 -->
        <template id="myAccount">
            <div>
                <h2>登录页面</h2>
                <h3>注册页面</h3>
            </div>
        </template>
    
        <div id="app">
            <!-- 使用组件 -->
            <account> </account>
        </div>
    
        <script>
    
            //定义、注册组件
            Vue.component('account', {
                template: '#myAccount'    // template 是 Vue 中的关键字，不能改。
            });
        </script>



vue封装组件的流程：
    ● 首先，使用Vue.extend()创建一个组件

    ● 然后，使用Vue.component()方法注册组件
    
    ● 接着，如果子组件需要数据，可以在props中接受定义
    
    ● 最后，子组件修改好数据之后，想把数据传递给父组件，可以使用emit()方法

以插件的形式封装组件：
    首先是一个.vue结尾的组件，和一个index.js的文件。
    插件的使用是，Vue.use()的，所以在index.js文件里中封装的插件要有个insatll方法包裹起来，参数第一个是默认的vue实例，剩下的是use的时候传进来的参数。
    然后使用Vue.extend({
                    render(h){
                        return h('message-box', {
                            props
                        });
                    }
                });来创建的是一个组件构造器。
    引入.vue结尾的组件，使用Vue.component(_MessageBox.name, _MessageBox)传入组件名，以及组件本身来注册;
    组件.$destroy()的方式来销毁组件，配置销毁的方法
    然后再在组件中用props来接收传递的数据，要是有方法的化，通过this.$emit, this.$on就行了


以组件的方式：
    如果要封装的组件较少的话，就直接在components文件夹下大驼峰创建.vue结尾的组件，写进去template,script,style.再使用props来接收数据，使用this.$emit, this.$on来处理传来的的方法即可



vue的动态路由是什么，动态路由怎么做、在什么时候做：
    1. router下index.js配置路由。
    {
        path：'/user/:id',
        component: User
    }

    2. 点击访问时，页面配置
    <template>
        <div id="detail">
            <router-link :to="'/user/'+userId"></router-link>
        </div>
    </template>
    <script>
    export default {
        name: 'detail',
        data() {
            return {
                userId: 'zgangdsna'
            }
        }
    }
    
    3. 获取参数的方式
    <h2>{{$route.params.id}}</h2>







this.$router为什么可以在全局使用：
    Vue-Router是一个vue插件，vue插件要有install方法。
    Vue-Router的install:
        首先获取了在router文件夹下的Index.js文件中定义的路由的信息参数
        使用vue.mixin混入：在beforeCreate 钩子函数中根据路由信息参数初始化路由，并且用defineReactive实现了路由的双向绑定。
    然后通过Object.defineProperty监听注册$router到vue上

    // 定义Vue.$router的返回值
    Object.defineProperty(Vue.prototype, '$router', {
        get () { return this._routerRoot._router }
    })
    
    // 定义Vue.$route的返回值
    Object.defineProperty(Vue.prototype, '$route', {
        get () { return this._routerRoot._route }
    })







简历上：
funguy博客论坛：
    pc端注册登录的实现：
        图片验证码的生成：
            首先我在nodejs后端用pgd-bm包下的BMP24属性，根据26个英文字母和十位数字生成了随机的四位的验证码图片。然后把图片以及图片上的字符返回给前端。供图片验证码验证。
            // 26个英文字母中随机取四位

        用户名密码的非对称加密：
            nodejs中用rsa（非对称加密），将加密后的用户名密码返回给前端，（这里应该把用户密码加密一下存入数据库），前端每次请求的时候都把用户名密码携带进请求头Authorization里。后端用私钥解密后再从数据库查数据。
    
        个人信息修改里：
            包括头像，昵称以及性别，个性签名等信息的上传到数据库。头像是单独上传的，图片上传。修改信息那里加了节流。
    
        图片上传:
            前端：
                就是隐藏一个<form :action="$http.defaults.baseURL+ 'touXiang'" method="POST" enctype="multipart/form-data" name="touXiangForm" target="tg">标签.
                input上传图片的@change事件绑定了：
                    handleFile(e){
                        let target = e.target || e.srcElement
                        let file = target.files[0]
                        if(file.size > 1050000){
                            return this.$message.error("图片过大")
                        }
                        var reader = new FileReader();
                        reader.onload = res => {
                            this.imgSrcPre = res.target.result;
                        }
                        //将文件以Data URL形式读入页面
                        reader.readAsDataURL(file)
                        this.dialogVisible = true
                    },
                通过new FileReader()来实现，将本地图片可以解析成base64格式，然后放在img标签的src属性里。
            后端： 
                用multer包：
                    根据当前时间以及图片的后缀名当做上传的路径，配置好multer的参数，图片存储在文件夹里。
        
        博客编辑发布：
            mavon-editor包与他的样式， :toolbars="toolbars"来配置，让编辑器头部显示什么功能，与不显示什么功能。
    
        博客查看功能:
            这个页面用了简单的媒体查询，根据屏幕宽度写了两个页面，相当于也是适配移动端了。






交友盲盒小程序：
    图片上传：
        wx.cloud.uploadFile上传图片，传入要存入在云存储的路径，以及本地wx.chooseImage的图片。然后成功的回调后会能够获得图片在云存储里的fileID，上传进数据库中。
    登录功能：
        在页面的onload生命周期中调用登录的云函数，登录的云函数里显示查看数据库里是否有md5加密的openId，有的话就说明已经登陆过了，直接返回数据，没有的话，就直接将openId md5加密，放入数据库里。

    下拉刷新：
        app.json的window字段"enablePullDownRefresh": true。
    
    触底加载新数据：
        传入将要查的页数，进行skip,limit,获取数据与之前的数据进行拼接，然后this.setData()就行了
    
    本地存储：
        用户信息存在本地，不用每次onload都触发登陆
        wx.setStorage
        wx.getStorage
        wx.removeStorage
        然后加上成功的回调

定位：
    wx.getLocation

调高德api
    实现路线规划：
        下载qqmap-wx-jssdk包，在页面引入。传入腾讯位置服务里申请的key,来实例化。然后
        调用像路线规划的方法，传入步行的方式，还是驾车的方式就可以实现路线规划。还可以调用地址逆解析方法，传入位置经纬度，然后就可以出来在地图上的具体中文位置。







区分数据类型：
    Object.prototype.toString.call(obj)
        toString方法返回反映这个对象的字符串。

    console.log(null.toString());//error
obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？
    因为toString为Object的原型方法，而Array 、Function等类型作为Object的实例，都重写了toString方法。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString方法（Function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串.....），而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型;

    我们可以验证一下，将数组的toString方法删除，看看会是什么结果：
        var arr=[1,2,3];
        console.log(Array.prototype.hasOwnProperty("toString"));//true
        console.log(arr.toString());//1,2,3
        delete Array.prototype.toString;//delete操作符可以删除实例属性
        console.log(Array.prototype.hasOwnProperty("toString"));//false
        console.log(arr.toString());//"[object Array]"
        删除了Array的toString方法后，同样再采用arr.toString()方法调用时，不再有屏蔽Object原型方法的实例方法，因此沿着原型链，arr最后调用了Object的toString方法，返回了和Object.prototype.toString.call(arr)相同的结果。



this指向： Nodejs中的this。

计算字符串表达式。    词法分析，语法分析。

数据持久化



mongodb: 
    // 查找
    db.user.find({"age": 13, "name": "zhangsan"})
    // 插入
    db.user.insert({"name": "xw", "age": 13})
    // 更新
    db.user.update({"name": "zhangsan"}, {$set: {"name": "张三"}})
    // 删除
    db.user.remove({"name": "wangwu"})

    ##### 给user表设置索引(1:升序， -1： 降序)
    db.user.ensureIndex({"username": 1})
    ##### 删除user表的索引
    db.user.dropIndex({"username": 1})
    
    <!-- 简单的聚合管道 -->
    ##### 只显示order_id与all_price字段，并且筛选all_price大于等于90的数据$match
    ##### 结果的降序排列 $sort, $limit限制数量，$skip:跳过几条数据
    db.order.aggregate([
    ​	{ $project: {order_id: 1, all_price: 1} }
    ​	{ $match: {"all_price": {$gte: 90}} }
    ​	{ $sort: {"all_price": -1} }
    ​	{ $skip: 1 }
    ​	{ $limit: 5 }
    ])


缓存失效问题
    我们明明更新了系统版本，为什么客户端看到的还是老文件。在不同的时代有不同的解决方案。

    老方案通过人工自己修改文件名或者在文件名后带上版本号、时间戳，这样客户端就会当新文件请求并使用，之前的强缓存就算在有效期内也会失效。
    <script src="http://randy.js?version=1.1.1> </script>
    
    在现在的构建阶段基本上都不需要人工操作了，都是使用构建工具比如Wbpack、Gulp、Grunt等构建工具自动构建。比如在使用Webpack构建的时候，会根据文件名或文件内容自动计算hash值来给文件命名，当内容或文件名发生改变的时候，构建出来的文件名也一定会不一样，这样也解决了强缓存还在有效期内的问题。


nginx进行缓存配置：
    如果我们使用Nginx作为Web服务器，我们可以如下配置
    location / {
        # 其它配置
        ...
        if ($request_uri ~* .*[.](js|css|map|jpg|png|svg|ico)$) {
            #非html缓存1个月
            add_header Cache-Control "public, max-age=2592000";
        }
        if ($request_filename ~* ^.*[.](html|htm)$) {
            #html文件使用协商缓存
            add_header Cache-Control "no-cache";
        }
    }


缓存存的位置：
    按缓存位置分类我们可以分为memory cache、disk cache、Service Worker三类
    memory cache 是内存中的缓存。按照操作系统的常理：先读内存，再读硬盘。    sessionStorage
    
    disk cache是存储在硬盘上的缓存，因此它是持久存储的，是实际存在于文件系统中的。而且它允许相同的资源在跨会话，甚至跨站点的情况下使用                        locationStorage
    
    service work给予了我们另外一种更加灵活，可以直接的操作方式。我们可以从 Chrome 的 Application找到Service Workers。这个缓存是永久性的，即关闭 TAB 或者浏览器，下次打开依然还在(而 memory cache 不是)。有两种情况会导致这个缓存中的资源被清除：手动调用 API cache.delete(resource) 或者容量超过限制，被浏览器全部清空。


Service Worker本质上也是浏览器缓存资源用的，只不过他不仅仅是cache，也是通过worker的方式来进一步优化:
    可以在Application的Cache Storage中查看缓存的具体内容：
    https://blog.csdn.net/frontend_frank/article/details/105697535



重排优化建议：
    尽量只修改position：absolute或fixed元素，对其他元素影响不大
    动画开始GPU加速，translate使用3D变化

    transform 不重绘，不回流
    是因为transform属于合成属性，对合成属性进行transition/animate动画时，将会创建一个合成层。这使得动画元素在一个独立的层中进行渲染。当元素的内容没有发生改变，就没有必要进行重绘。浏览器会通过重新复合来创建动画帧。



BFC:
    创建：浮动元素 display：inline-block position:absolute 
    应用: 1.分属于不同的BFC时,可以防止margin重叠 2.清除内部浮动 3.自适应多栏布局


原型: 对象中固有的__proto__属性，该属性指向对象的prototype原型属性。

原型链: 当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是Object.prototype所以这就是我们新建的对象为什么能够使用toString()等方法的原因。





es6的super 关键字：
    既可以当作函数使用：
        作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次 super() 函数。作为函数时，super() 只能用在子类的构造函数之中。
    super 作为对象使用：
        super 作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。








vue-simple-uploader是基于 simple-uploader.js 封装的vue上传插件。它的优点包括且不限于以下几种：
    ① 支持文件、多文件、文件夹上传；支持拖拽文件、文件夹上传
    ② 可暂停、继续上传
    ③ 错误处理
    ④ 支持“秒传”，通过文件判断服务端是否已存在从而实现“秒传”
    ⑤ 分块上传
    ⑥ 支持进度、预估剩余时间、出错自动重试、重传等操作






vue3双向数据绑定优势：
    相比于vue2.x，使用proxy的优势如下
        1 defineProperty只能监听某个属性，不能对全对象监听
        2 可以省去for in、闭包等内容来提升效率（直接绑定整个对象即可）
        3 可以监听数组，不用再去单独的对数组做特异性操作
        vue3.x可以检测到数组内部数据的变化




react了解



history刷新后404解决：
    使用 history 模式时，URL 就像正常的 url，可以直接访问http://www.xxx.com/user/id，但是因为vue-router设置的路径不是真实存在的路径，所以刷新就会返回404错误。
    后端对应配置路由路径。
    服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。
    也就是在服务端修改404错误页面的配置路径，让其指向到index.html。





instanceof 是用来判断 A 是否为 B 的实例，表达式为：A instanceof B。在这里需要特别注意的是：instanceof 检测的是原型。




直接使用b标签和使用css的font-weight有什么区别：
    使用 b 标签标记的内容浏览器会使用相应的默认 CSS 样式来渲染。b 标签是一个单纯的 HTML样式标签，它指定文本要用粗体， 而font-weight是可以定义由粗到细的字符。400 等同于 normal，而 700 等同于 bold。100 - 900；



websocket相关：
    执行双方握手过程，客户端发送数据格式类似：

    GET /webfin/websocket/ HTTP/1.1
    
    Host: localhost
    
    Upgrade: websocket           // websocket参数值表明这是WebSocket类型请求
    
    Connection: Upgrade     
    
    Sec-WebSocket-Key: xqBt3ImNzJbYqRINxEFlkg==    // 是WebSocket客户端发送的一个 base64编码的密文,要求服务端必须返回一个对应加密的Sec-WebSocket-Accept应答，否则客户端会抛出Error during WebSocket handshake错误，并关闭连接。
    
    Origin: http://localhost:8080
    
    Sec-WebSocket-Version: 13


websocket应用： 金融证券的实时信息、Web导航应用中的地理位置获取、社交网络的实时消息推送， 大文件上传等。常见的轮询方案，其原理简单易懂，就是客户端以一定的时间间隔频繁请求的方式向服务器发送请求，来保持客户端和服务器端的数据同步。其问题也很明显：当客户端以固定频率向服务器端发送请求时，服务器端的数据可能并没有更新，带来很多无谓请求，浪费带宽，效率低下。
Websocket协议通过第一个request建立了TCP连接之后，之后交换的数据都不需要发送 HTTP header就能交换数据



websocket原理：
    WebSocket是HTML5新生的一种双向通信协议， 实现了浏览器与服务器全双工通信。在建立连接后，WebSocket服务器端和客户端都能主动向对方发送或接收数据，就像Socket一样；
    WebSocket需要像TCP一样，先建立连接，连接成功后才能相互通信。

websocket的使用：
    if ('WebSocket' in window) {
    websocket = new WebSocket("地址");
    } else {
        // 不支持websocket
    }
    websocket.send = ('msg')
    alert(websocket.readyState) // websocket的准备状况
    websocket.onerror = function(){}
    websocket.onopen = function(){}
    websocket.onmessage = function(){}
    websocket.onclose = function(){}




cors响应头：
    response.setHeader("Access-Control-Allow-Origin",'*');
        response.setHeader("Access-Control-Allow-Headers",'*');
        response.setHeader("Access-Control-Allow-Method",'*');
        response.send('hello CORS');






<!-- 前端优化 -->

1、前端优化
  js和css优化相同、重复的部分放到此处。
  1、script标签放在body标签尾部，css link标签引用放在head标签内，减少白屏时间。
  2、合理使用http缓存，js、css文件资源合并，使用精灵图，图片使用base64编码，懒加载等，减少http请求数。js、css文件压缩，gzip压缩，去除空格回车等多余字符。

2、CSS性能优化
  1、减少首屏加载css的时间，将首屏加载的关键css内联到html中，Github上有一个项目Critical CSS4，可以将属于首屏的关键样式提取出来。
  2、在减少首屏css加载完后，异步加载css，css会阻塞渲染，在css文件请求、下载、解析完成之前，浏览器将不会渲染任何处理的内容，
  3、去除无用的css样式。
  4、有选择的使用选择器，尽量少使用标签、通配符、属性选择器，也不要用id选择器去修饰标签选择器，没有意义。
  5、适当减少消耗想能较高的css属性，如box-shadow、透明度等。
  6、优化重排和重绘，避免不必要的重排和重绘。
  7、不要使用@import引用外部样式，
  8、减少css嵌套
  9、建立公共样式表，提取相同样式出来作为公共类使用。如清楚浮动。
  10、少用css表达式，虽然让你代码看起来比较酷炫，但是性能消耗大。
  减少不必要的样式重置css reset。

// 什么是样式重置？修改html大部分标签在游览器中的默认样式。
h1, h2, h3, h4, h4, h5 {
	margin:0;
	padding:0;
}
1
2
3
4
5
3、js性能优化
  1、阻塞式脚本资源加载，合并资源减少http请求数。
  2、非阻塞式脚本资源加载：延迟脚本和动态脚本均不阻塞，即下载过程不阻塞其他进程。
    （1）延迟脚本，defer和async，async下载完成立即执行，defer，页面加载完成再执行。
    （2）动态脚本，动态添加script标签，返回的代码通常会立刻执行。
  3、减少全局变量的使用，访问全局变量比访问局部变量要慢。
  4、减少DOM操作，涉及大量的DOM元素增加删除，使用文档随便document.createDocumentFragment一次性生成。
  5、使用prefetch进行DNS预解析。
  6、垃圾回收，不适用的对象重置为null，否则可能因为互相引用对象而造成内存使用率不断提高。
  7、事件委托，不必为每一次子元素都添加事件，添加到父容器上，通过冒泡标签判断触发事件。






margin重叠问题：
    a、全部都为正值，取最大者；
    b、不全是正值，则都取绝对值，然后用正值减去最大值；
    c、没有正值，则都取绝对值，然后用0减去最大值。




<!-- ajax轮训的代码实现 -->
<script>
    setInterval("test()",500);
    function test() {
        $.ajax({
            url: '/new_window_url/',
            async:true,
            type: 'get',
            success: function (data) {
                var new_url =  $('#new_iframe').attr('src');
                if (new_url !== data){
                    $('#new_iframe').attr('src', data);
                }
            }
        })
    }
</script>





http缓存的响应头控制：
强缓存：
    //禁止客户端对该次响应的内容复制至缓存区域
    header('Cache-Control: no-store');

    //客户端下一次请求进行缓存有效度验证时，不使用该次的相应结果
    header('Cache-Control: no-cache');
    
    //设置缓存有效期是0，客户端下一次请求不使用缓存
    header('Cache-Control: max-age=0');
    
    //客户端下一次请求时，必须对缓存有效性进行重新验证再使用
    header('Cache-Control: must-revalidate');
协商缓存：
    If-Modified-Since：请求头，资源最近修改时间，由浏览器告诉服务器

    Last-Modified：响应头，资源最近修改时间，由服务器告诉浏览器
    
    Etag：响应头，资源标识，由服务器告诉浏览器
    
    If-None-Match：请求头，缓存资源标识，由浏览器告诉服务器









![image-20220328091417871](%E6%8E%98%E9%87%91.assets/image-20220328091417871.png)




什么时候进行垃圾回收： 
    因 js 引擎不同而策略不一样。
    基本都会在空闲时再去进行垃圾回收，而V8已经实现了并发标记，该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行。

    每次进行垃圾回收，会停止服务的提供直到垃圾回收完毕
    
    执行多次标记清除就会执行一次标记整理。无论是标记清除还是标记整理或者是新生代的循环都是耗时比较久的。所以V8做了一个优化方案为增量标记。把一个大的阶段拆分成很多的小阶段去执行这样Stop-The-World的影响就可以降到最低了。
    
    V8的垃圾回收机制分为新生代和老生代。
    新生代主要使用Scavenge进行管理，主要实现是Cheney算法，将内存平均分为两块，使用空间叫From，闲置空间叫To，新对象都先分配到From空间中，在空间快要占满时将存活对象复制到To空间中，然后清空From的内存空间，此时，调换From空间和To空间，继续进行内存分配，当满足那两个条件时对象会从新生代晋升到老生代。
    
    老生代主要采用Mark-Sweep和Mark-Compact算法，一个是标记清除，一个是标记整理。两者不同的地方是，Mark-Sweep在垃圾回收后会产生碎片内存，而Mark-Compact在清除前会进行一步整理，将存活对象向一侧移动，随后清空边界的另一侧内存，这样空闲的内存都是连续的，但是带来的问题就是速度会慢一些。在V8中，老生代是Mark-Sweep和Mark-Compact两者共同进行管理的。



执行上下文有什么：
    Javascript引擎的两个基本部分：执行上下文和调用堆栈。
    每次运行一些Javascript代码是，引擎都会创造一个全局执行上下文。
        执行上下文是一个比喻的词，用于描述运行Javascript代码的环境。
    当Javascript引擎运行您的代码时，它会创建：
        全局执行上下文
        全局存储器（也称为全局作用域或全局变量环境）
    Javascript引擎需要跟踪发生的情况：
        它依赖于调用栈。调用栈就像是程序当前执行的日志。
            它有两种方法：push和pop。
            push是将某些东西放入堆栈的行为。
                当在Javascript中运行函数时，引擎会将该函数push到调用堆栈中。
            每个函数调用都被push到调用栈中。
            push的第一件事是main()（或global()），它是Javascript程序执行的主要线程。
            pop另一端是从堆栈中删除某些东西的行为。
                当函数执行结束时，将从调用栈中pop出去。
    Javascript引擎创建执行上下文，全局存储器和调用栈。但是一旦你调用一个函数，引擎就会创建一个局部执行上下文。



作用域链什么时候创建的：
    作用域链在函数定义时已经确定了，作用域链是和函数定义时的位置相关的。在函数创建的时候创建一个包含外部对象（包括全局对象和所有包含自己的对象）的作用域链，储存在内部[[scope]]属性中。函数执行的时候会创建一个执行环境，通过复制[[scope]]属性中的对象，构建执行环境的作用域链，并把自己的活动对象推向当前作用域链的前端以此形成完整的作用域链。[[scope]]属性中保存的是对可访问变量对象的引用，而不是值的复制。



如何减少垃圾的频繁回收：
    new关键字就意味着一次内存分配，例如 new Foo()。在初始化的时候新建对象，然后在后续过程中尽量多的重用这些创建好的对象。

    对象object优化：
        那就是遍历此对象的所有属性，并逐个删除，最终将对象清理为一个空对象。短暂的时间消 耗，将会有效的减少垃圾堆积，并且最终避免垃圾回收暂停
    
    Array的优化：
        将数组长度赋值为 0（arr.length = 0）也能达到清空数组的目的，并且同时能实现数组重用。
        slice方法会返回一个新的数组对象（数组中的元素是原数组中删掉的部分），并且会通过 arr.push.apply方法将元素重新复制回原数组，但是在此操作之后，该数组就成为了一片内存垃圾。
    
    function优化：
        不要将方法当做定时器的返回值。



params刷新页面丢失的问题：
    使用sessionStorage、localStorage
    使用params中的路由匹配：
        在router.js，即匹配路由规则的位置，加上占位符即可
        {
            path: '/index/:num/:name',
            name: 'index',
            component: Index
        }


vue data中数据变化视图会立即重新渲染吗：
    原始类型会立即渲染
    引用数据类型不行。
        数组的话用那几个监听过的方法。
        对象的话用this.$set()


vue   template -> 真实DOM的过程
1. 获取到tempalte
2. template -> AST树：抽象语法树， 源代码的抽象语法结构的树状描述
3. AST -> render函数  -> _c   _v   _s
4. render函数  ->  虚拟节点
5. 设置patch  ->  打补丁到真实DOM



Vuex事件处理机制：
    vue.js中通过store.dispatch将值传递给vuex中的actions属性，actions中通过store.commit，将值传递给mutations的某个处理函数中，然后通过mutations改变state的状态值


document.ready和window.onload的区别
    页面加载完成有两种事件，一是ready，表示文档结构已经加载完成（不包含图片等非文字媒体文件），二是onload，指示页面包含图片等文件在内的所有元素都加载完成。

进程、线程、协程的区别：




// 9. position的属性，尽可能全部说完。stickey怎么用。absolute是相对什么定位的。
// 祖先元素怎么定位，position:absolute会相对于其定位



// js部分出了三道蛮简单的题：数组去重，斐波那契数列求第n个的值，#ffffff转rgb(255,255,255) 
// 然后如果是简写成#fff再来转怎么处理。 每道题都先讲思路再写，写完分析时间空间复杂度

// http报文的的格式,   封装过什么组件
    十六进制ASCII码

请求报文：
    GET /admin_ui/rdx/core/images/close.png HTTP/1.1
    Accept: */*
    Referer: http://xxx.xxx.xxx.xxx/menu/neo
    Accept-Language: en-US
    User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET4.0C; .NET4.0E)
    Accept-Encoding: gzip, deflate
    Host: xxx.xxx.xxx.xxx
    Connection: Keep-Alive
    Cookie: startupapp=neo; is_cisco_platform=0; rdx_pagination_size=250%20Per%20Page; SESSID=deb31b8eb9ca68a514cf55777744e339
响应报文：
    HTTP/1.1 200 OK
    Bdpagetype: 1
    Bdqid: 0xacbbb9d800005133
    Cache-Control: private
    Connection: Keep-Alive
    Content-Encoding: gzip
    Content-Type: text/html
    Cxy_all: baidu+f8b5e5b521b3644ef7f3455ea441c5d0
    Date: Fri, 12 Oct 2018 06:36:28 GMT
    Expires: Fri, 12 Oct 2018 06:36:26 GMT
    Server: BWS/1.1
    Set-Cookie: delPer=0; path=/; domain=.baidu.com
    Set-Cookie: BDSVRTM=0; path=/
    Set-Cookie: BD_HOME=0; path=/
    Set-Cookie: H_PS_PSSID=1433_21112_18560_26350_27245_22158; path=/; domain=.baidu.com
    Vary: Accept-Encoding
    X-Ua-Compatible: IE=Edge,chrome=1
    Transfer-Encoding: chunked
    
    <!DOCTYPE html>
    <!--STATUS OK-->


路由守卫；

​	全局路由守卫：beforeEach, afterEach

​	独享路由守卫：

​	![image-20220330091806653](%E6%8E%98%E9%87%91.assets/image-20220330091806653.png)

    组件内路由守卫：
        beforeRouteEnter
        beforeRouteLeave



前端数据持久化：webSQL
    openDatabase() 方法对应的五个参数说明：数据库名称, 版本号, 描述文本, 数据库大小, 数据库大小, 创建回调
    var db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024);
    db.transaction(function (tx) {  
        tx.executeSql('CREATE TABLE IF NOT EXISTS LOGS (id unique, log)');
    });



CSS动画之硬件加速
    3D 和 2D transform 的区别就在于，浏览器在页面渲染前为3D动画创建独立的复合图层，而在运行期间为2D动画创建。动画开始时，生成新的复合图层并加载为GPU的纹理用于初始化 repaint。然后由GPU的复合器操纵整个动画的执行。最后当动画结束时，再次执行 repaint 操作删除复合图层。

    下面的会触发硬件加速：
        transform
        opacity




项目中的难点:
    难点其实就是因为没有实现过嘛，然后真正把这个难点搞定了也就不怎么难了

    在移动端里的首页，就是刷视频的界面，刷视频的话就会有一些像双击了，还有上下滑动加载下一个视频了，还有长按跳出个全屏的框，来弹出下载的按钮，这些就是通过touchstart,touchend,touchmove.这三个事件，再加上通过定时器来进行判断触发的是点击事件，还是长按事件，这些， 而且还要解决移动端的点击穿透的问题。

    图片懒加载：那里


项目部署中遇到的困难：
    主要是上线的时候遇到了困难，虽然就是也了解webpack打包的一些基础，但是上线的话暂时还没有搞定，服务器上也装了node环境，mongodb环境，还有把本地的mongodb数据也导进去了，但是还是运行不了，我觉得这最大的问题很可能是是写项目的时候规范的问题，包括前端的项目规范，还有后端的一些规范。所以我最近就是再看人家的弄得比较规范的项目，然后再进行学习。


还有就是规范的问题：虽然知道一些状态码代表的什么，但是并没有在项目中体现出来，接口方面的规范做的可能不是很到位。




项目的亮点：
    我觉得用到的技术比较多也算是亮点吧。

    首先这是一个前端vue，然后后端用nodejs加mongodb的项目。

    在博客分享页面用的媒体查询，来适配移动端与pc端。

    *** 然后又在vue的路由配置那里，通过navigator.userAgent.match(/(phone|pad|pod|iPhone|Windows Phone)/i)来匹配移动端的设备，进行两套路由的配置。

    postcss-px-to-viewport来适配移动端，用了这个就可以使用vw来写代码的，然后在编译的时候会自动转换成px，然后可以给他进行一些配置，例如是否允许在媒体查询中转换`px`等，因为这个项目是移动端跟pc端都有的嘛，所以最主要的是要配置下让他只转换移动端的代码。

    有又图片懒加载的实现。

    还有前后端配合进行图片，multer进行图片上传的操作。

    websocket技术
    


循环遍历所用时间对比：
    for循环遍历 < for...of遍历 < forEach遍历 < for...in遍历 < map遍历
    因为for … in语法是第一个能够迭代对象键的JavaScript语句，循环对象键({})与在数组([])上进行循环不同，引擎会执行一些额外的工作来跟踪已经迭代的属性。
    数据量大时，遍历性能的差距尤为明显；

    for系遍历总体性能好于forEach、map等数组方法
    forEach性能优于map
    for…of要兼容低版本设备的话还是算了



浏览器渲染相关：
    https://www.imooc.com/article/40004


symbol的使用：
    symbol(1)
    symbol('1')

    使用 Symbol.for() 方法和  Symbol.keyFor() 方法从全局的symbol注册表设置和取得symbol。

    Symbol.prototype.toString
    Symbol.prototype.valueOf

    Symbols 在 for...in 迭代中不可枚举。另外，Object.getOwnPropertyNames() 不会返回 symbol 对象的属性，但是你能使用 Object.getOwnPropertySymbols() 得到它们。




DOM 对象及其元素的层级关系：
    Window	Javascript层级中的顶级对象。window对象表示浏览器窗口。每当<body>或<frame>标签出现，window对象会被自动创建。
    Navigator	包含客户端浏览的信息。
    Screen	包含客户端显示屏的信息。
    History	包含浏览器窗口访问过的URL。
    Location	包含了当前URL的信息。

    window.     window包含以上四个;



webpack4中hash、chunkhash和contenthash三者的区别:
    通过webpack构建之后，生成对应文件名自动带上对应的MD5值。
    只要项目里有文件更改，整个项目构建的hash值都会更改。并且全部文件都共用相同的hash值

    chunkhash它根据不同的入口文件(Entry)进行依赖文件解析、构建对应的chunk，生成对应的hash值。只要我们不改动公共库的代码，就可以保证其哈希值不会受影响。

    contenthash表示由文件内容产生的hash值，内容不同产生的contenthash值也不一样。可以使用extra-text-webpack-plugin里的contenthash值，保证即使css文件所处的模块里就算其他文件内容改变，只要css文件内容不变，那么不会重复构建。




声明式编程 ：告诉机器你想要的是什么    让机器想出去做  

优缺点 ： 声明式减少了可变量(Immutable Variable)的声明，程序更为安全，   代码更加简洁  好的命名代码可读性更强




对于一份同逻辑的代码，当我们手写下一个一个的文件，它们无论是 ESM 还是 commonJS 或是 AMD，他们都是 module ；
当我们写的 module 源文件传到 webpack 进行打包时，webpack 会根据文件引用关系生成 chunk 文件，webpack 会对这个 chunk 文件进行一些操作；
webpack 处理好 chunk 文件后，最后会输出 bundle 文件，这个 bundle 文件包含了经过加载和编译的最终源文件，所以它可以直接在浏览器中运行。




协商缓存：

    Last-Modified 是什么
    Last-Modified 是 HttpHeader 中的资源的最后修改时间，如果带有 Last-Modified ，下一次发送 Http 请求时，将会发生带 If-modified-since 的 HttpHeader 。如果没有过期，将会收到 304 的响应，从缓存中读取。

    Etag 是什么
    Etag 是 HttpHeader 中代表资源的标签，在服务器端生成。如果带有 Etag ，下一次发送带 Etag 的请求，如果 Etag 没有变化将收到 304 的响应，从缓存中读取。

    Etag 在使用时要注意相同资源多台 Web 服务器的 Etag 的一致性。






为什么要分微任务和宏任务？

    微任务是线程之间的切换，速度快。不用进行上下文切换，可以快速的一次性做完所有的微任务。
    宏任务是进程之间的切换，速度慢，且每次执行需要切换上下文。因此一个Eventloop中只执行一个宏任务。

    而区分微任务和宏任务的根本原因是为了插队。由于微任务执行快，一次性可以执行很多个，在当前宏任务执行后立刻清空微任务可以达到伪同步的效果，这对视图渲染效果起到至关重要的作用。






vueX原理：
    store注入组件install方法，
    Vue.mixin({
        beforeCreate() {
            if (this.$options && this.$options.store) {
                //找到根组件 main 上面挂一个$store
                this.$store = this.$options.store
                // console.log(this.$store);

            } else {
                //非根组件指向其父组件的$store
                this.$store = this.$parent && this.$parent.$store
            }
        }
    })
    store注入 vue的实例组件的方式，是通过vue的 mixin机制，借助vue组件的生命周期 钩子。beforeCreate 完成的。即 每个vue组件实例化过程中，会在 beforeCreate 钩子前调用 vuexInit 方法。
    我们可以看出Vuex的state状态是响应式，是借助vue的data是响应式，将state存入vue实例组件的data中；Vuex的getters则是借助vue的计算属性computed实现数据实时监听。






    // 用来获取滚动的距离，顶部距离浏览器内上边框的距离(为负值)，反过来就为
        let scrollLen = document.documentElement.getBoundingClientRect().top
    // 滚动条的总高度
        let scrollTotalLen = document.documentElement.scrollHeight
    // 窗口高度
        let clientLen = document.documentElement.clientHeight




504错误代表网关超时 （Gateway timeout），是指服务器作为网关或代理，但是没有及时从上游服务器收到请求。




promise的实现




e.currentTarget指的是注册了事件监听器的对象, 而e.target指的是该对象里的子对象，也是触发这个事件的对象。





小程序遇到的问题：
    onshow频繁触发解决：
        chooseImage与previewImage都会触发，定义一个外部的开关变量，在onload的时候判断开关变量，在触发chooseImage事件的时候更改开关变量就好了


    还有就是那项目里调用高德地图的api实现路线规划的时候，当时没有头绪，就去高德那开发文档看嘛，
        让下载个 amap-wx.js包,  var myAmapFun = new amapFile.AMapWX({key: '高德Key'});
        实例化的时候把在高德开放平台申请的对应小程序应用的key传进去
        调用 getDrivingRoute 方法，骑行，打车，步行都可以。

        后来发现腾讯位置服务也有这个功能，他是一个路线规划插件的形式，需要在小程序插件里添加插件routePlan，以及app.json里引入插件的包，还要小程序的定位授权，然后就是使用插件了，wx.navigateTo({url: 'plugin://routePlan/index?key=' + key + '&referer=' + referer + '&endPoint=' + endPoint});
        传进去在腾讯位置服务申请的Key，还有终点的经纬度，还要配置域名白名单。大概流程就是这样。我当时就是忘了配置域名白名单，怎么都获取不到数据。后面就仔细看了几遍那个流程，才解决了。



Vue.set(vm.someObject, 'b', 2)
this.$set(this.someObject,'b',2)
vm.$set(vm.items, indexOfItem, newValue)

由于 Vue 会在初始化实例时对 property 执行 getter/setter 转化，所以 property 必须在 data 对象上存在才能让 Vue 将它转换为响应式的






vuex的state, getter响应式的实现：
    由于Vue实例对象的data和computed属性是响应式的，那么就可以通过实例对象重设store，将state注册到实例对象的data中，将Getters注册到实例对象的computed中，进而实现了Vuex是响应式的。

    将所有的Getters存放到computed对象中，然后在下面的new Vue实例中，将其注册为computed

    Object.defineProperty(store.getters, key, {
      get: () => store._vm[key],     // get的时候，从store中去拿
      enumerable: true // for local getters
    })

    让store._vm指向一个新的Vue实例，而该新的Vue实例目的是将Vuex中的state和getters分别注册到
	Vue实例的data和computed中。




diff:
    updateChildren
    将Vnode的子节点Vch和oldVnode的子节点oldCh提取出来。
    oldCh和vCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx>EndIdx表明oldCh和vCh至少有一个已经遍历完了，就会结束比较。



浏览器渲染篇:
            建立图层树(Layer Tree)
            生成绘制列表
            生成图块并栅格化
            显示器显示内容
            最后断开连接：TCP 四次挥手
            (浏览器会将各层的信息发送给GPU,GPU会将各层合成,显示在屏幕上)


loader和plugin对比？
    Loader 在 module.rules 中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性。
    Plugin 在 plugins 中单独配置，类型为数组，每一项是一个Plugin的实例，参数都通过构造函数传入。




渐进增强（Progressive Enhancement）：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。

优雅降级（Graceful Degradation）：一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。





浏览器的兼容性问题：
360浏览器,猎豹浏览器：IE+Chrome双内核
Chrome浏览器：Webkit内核，现在是Blink内核
Firefox浏览器：Gecko内核，俗称Firefox内核
Safari浏览器：Webkit内核

    不同浏览器的标签默认的margin和padding不一样。*{margin:0;padding:0;}

    IE下，可以使用.方法来获取自定义属性,也可以使用getAttribute()获取自定义属性；Firefox下，只能使用getAttribute()获取自定义属性。解决方法:统一通过getAttribute()获取自定义属性。

    Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。

    渐进识别的方式，从总体中逐渐排除局部。首先，巧妙的使用“9”这一标记，将IE浏览器从所有情况中分离出来。接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。
    {
        background-color:#f1ee18;/*所有识别*/
        .background-color:#00deff\9; /*IE6、7、8识别*/
        +background-color:#a200ff;/*IE6、7识别*/
        _background-color:#1e0bd1;/*IE6识别*/
    }

    图片默认有间距     解决方案：使用float为img布局

    边距重叠问题；当相邻两个元素都设置了margin边距时，margin将取最大值，舍弃最小值；


    event.srcElement问题
    问题说明：IE下，event对象有srcElement属性，但是没有target属性；Firefox下，event对象有target属性，但是没有srcElement属性。
    解决方法：使用srcObj = event.srcElement?event.srcElement:event.target;

    对齐文本与文本输入框
        加上 vertical-align:middle;   在IE下任一版本都不适用，而ff、opera、safari、chrome均OK！

    超链接访问过后hover样式就不出现的问题
        被点击访问过的超链接样式不在具有hover和active了,很多人应该都遇到过这个问题,解决技巧是改变CSS属性的排列顺序: L-V-H-A



品字布局满屏

圣杯布局


响应式设计：   
    必须要有：
    <meta name="’viewport’" content="”width=device-width," initial-scale="1." maximum-scale="1,user-scalable=no”"/>





开启多个子进程
    const cluster = require('cluster');
    for (let i = 0; i < numCPUs; i++) {
        cluster.fork(); // 生成新的工作进程，可以使用 IPC 和父进程通信
    }


一个进程下开启多个线程：
    const {
        Worker, isMainThread, parentPort, workerData
    } = require('worker_threads');
    const worker = new Worker(__filename, {
        workerData: script
    });


使用SharedArrayBuffer，两个线程的两个WebWorker都可以在同一块内存中写入数据和读取数据。
这意味着它们不像postMessage那样具有通信开销和延迟。两个Web工作人员都可以立即访问到需要的数据。


常见的一个场景，在服务中若需要执行 shell 命令，那么就需要开启一个进程
var exec = require('child_process').exec;
exec('ls', function(error, stdout, stderr){
    if(error) {
        console.error('error: ' + error);
        return;
    }
    console.log('stdout: ' + stdout);
});
对于服务中涉及大量计算的，可以开启一个工作线程，由这个线程去执行，执行完毕再把结果通知给服务线程。





npm 模块安装机制
    发出npm install命令
    查询 node_modules 目录之中是否已经存在指定模块
    若存在，不再重新安装
    若不存在
    npm 向 registry 查询模块压缩包的网址
    下载压缩包，存放在根目录下的.npm目录里
    解压压缩包到当前项目的 node_modules 目录



devDependencies和dependencies的版本写法
    指定版本：比如1.2.2，遵循大版本.次要版本.小版本的格式规定，安装时只安装指定版本。
    波浪号（tilde）+指定版本：比如~1.2.2，表示安装1.2.x的最新版本（不低于1.2.2），但是不安装1.3.x，也就是说安装时不改变大版本号和次要版本号。
    插入号（caret）+指定版本：比如ˆ1.2.2，表示安装1.x.x的最新版本（不低于1.2.2），但是不安装2.x.x，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。
    latest：安装最新版本。



babel工作原理：
    babel是一个转译器，它只是把同种语言的高版本规则翻译成低版本规则
    babel的转译过程分为三个阶段：parsing、transforming、generating，以ES6代码转译为ES5代码为例，babel转译的具体过程如下：

    ES6代码输入 ==》  babylon进行解析   ==》   得到AST     ==》   plugin用babel-traverse对AST树进行遍历转译 ==》   得到新的AST树      ==》     用babel-generator通过AST树生成ES5代码

    babel只是转译新标准引入的语法，比如ES6的箭头函数转译成ES5的函数；而新标准引入的新的原生对象，部分原生对象新增的原型方法，新增的API等（如Proxy、Set等），这些babel是不会转译的。需要用户自行引入polyfill来解决

    plugins
    插件应用于babel的转译过程，尤其是第二个阶段transforming，如果这个阶段不使用任何插件，那么babel会原样输出代码。
    我们主要关注transforming阶段使用的插件，因为transform插件会自动使用对应的词法插件，所以parsing阶段的插件不需要配置。

    presets
    如果要自行配置转译过程中使用的各类插件，那太痛苦了，所以babel官方帮我们做了一些预设的插件集，称之为preset，这样我们只需要使用对应的preset就可以了。以JS标准为例，babel提供了如下的一些preset：
        es2015
        es2016
        es2017
        env
        es20xx的preset只转译该年份批准的标准，而env则代指最新的标准，包括了latest和es20xx各年份
        另外，还有 stage-0到stage-4的标准成形之前的各个阶段，这些都是实验版的preset，建议不要使用。

    polyfill
    polyfill是一个针对ES2015+环境的shim，实现上来说babel-polyfill包只是简单的把core-js和regenerator runtime包装了下，这两个包才是真正的实现代码所在（后文会详细介绍core-js）。
    使用babel-polyfill会把ES2015+环境整体引入到你的代码环境中，让你的代码可以直接使用新标准所引入的新原生对象，新API等，一般来说单独的应用和页面都可以这样使用。

    使用方法

    先安装包： npm install --save babel-polyfill
    要确保在入口处导入polyfill，因为polyfill代码需要在所有其他代码前先被调用
    代码方式： import "babel-polyfill"
    webpack配置： module.exports = { entry: ["babel-polyfill", "./app/js"] };
    如果只是需要引入部分新原生对象或API，那么可以按需引入，而不必导入全部的环境，具体见下文的core-js



选择器权值：
    第一等级：代表 内联样式，如 style=""，权值为 1,0,0,0；
    第二等级：代表 ID选择器，如 #id="", 权值为 0,1,0,0；
    第三等级：代表 calss | 伪类 | 属性 选择器，如 .class | :hover,:link,:target | [type], 权值 0,0,1,0；
    第四等级：代表 标签 | 伪元素 选择器，如 p | ::after, ::before, ::fist-inline, ::selection, 权值 0,0,0,1；
    此外，通用选择器（*），子选择器（>）， 相邻同胞选择器（+）等选择器不在4等级之内，所以它们的权值都为 0,0,0,0；

    比较规则就是三点
　　　　1.先从高等级进行比较，高等级相同时，再比较低等级的，以此类推；
　　　　2.完全相同的话，就采用 后者优先原则（也就是样式覆盖）；


requestAnimationFrame，
cancelAnimationFrame





template编译,:
    在$mount过程中，如果是使用独立构建，则会在此过程中将template编译成render function。当然，你也可以采用运行时构建。具体参考运行时-编译器-vs-只包含运行时。
    // 需要编译器
    new Vue({
        template: '<div>{{ hi }}</div>'
    })

    // 不需要编译器
    new Vue({
        render (h) {
            return h('div', this.hi)
        }
    })
    template是如何被编译成render function的呢:
        首先会将模板template进行parse得到一个AST语法树，再通过optimize做一些优化，最后通过generate得到render
            parse会用正则等方式解析template模板中的指令、class、style等数据，形成AST语法树。

        optimize
            optimize的主要作用是标记static静态节点，这是Vue在编译过程中的一处优化，后面当update更新界面时，会有一个patch的过程，diff算法会直接跳过静态节点，从而减少了比较的过程，优化了patch的性能。
        generate
            generate是将AST语法树转化成render funtion字符串的过程

    Watcher到视图
        Watcher对象会通过调用updateComponent方法来达到更新视图的目的。Watcher并不是实时更新视图的，Vue.js默认会将Watcher对象存在一个队列中，在下一个tick时更新异步更新视图，完成了性能优化。



var searchParams = new URLSearchParams(url);




应用级中间件
路由级中间件
错误处理中间件
内置中间件
第三方中间件




<!-- 类定义私有属性 -->

class IncreasingCounter {
  // Private class field
  #privateValue = 0;
  get value() {
    return this.#privateValue;
  }
  increment() {
    this.#privateValue++;
  }
}
 
const counter = new IncreasingCounter()
 
console.log(counter)


5. $(document).ready() 是个什么函数？为什么要用它？(answer)

这个问题很重要，并且常常被问到。 ready() 函数用于在文档进入ready状态时执行代码。当DOM 完全加载（例如HTML被完全解析DOM树构建完成时），jQuery允许你执行代码。使用$(document).ready()的最大好处在于它适用于所有浏览器，jQuery帮你解决了跨浏览器的难题。


11. $(this) 和 this 关键字在 jQuery 中有何不同？（答案如下）

这对于很多 jQuery 初学者来说是一个棘手的问题，其实是个简单的问题。$(this) 返回一个 jQuery 对象，你可以对它调用多个 jQuery 方法，比如用 text() 获取文本，用val() 获取值等等。而 this 代表当前元素，它是 JavaScript 关键词中的一个，表示上下文中的当前 DOM 元素。你不能对它调用 jQuery 方法，直到它被 $() 函数包裹，例如 $(this)。




-mask-image: linear-gradient


less


git merge rebase 对比



object的tostring和构造器的tostring的区别

Suspence支持顶层await?

3.3 Proxy的其他优势
    Proxy有多达13种拦截方法,不限于apply、ownKeys、deleteProperty、has等等是Object.defineProperty不具备的。
    Proxy返回的是一个新对象,我们可以只操作新的对象达到目的,而Object.defineProperty只能遍历对象属性直接修改。
    Proxy作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利。
    当然,Proxy的劣势就是兼容性问题,而且无法用polyfill磨平,因此Vue的作者才声明需要等到下个大版本(3.0)才能用Proxy重写。


基于数据劫持的双向绑定离不开Proxy与Object.defineProperty等方法对对象/对象属性的"劫持":
    利用Proxy或Object.defineProperty生成的Observer针对对象/对象的属性进行"劫持",在属性发生变化后通知订阅者
    解析器Compile解析模板中的Directive(指令)，收集指令所依赖的方法和数据,等待数据变化然后进行渲染
    Watcher属于Observer和Compile桥梁,它将接收到的Observer产生的数据变化,并根据Compile提供的指令进行视图渲染,使得数据变化促使视图变化






1.用new Object()

var obj=new Object();
2、创建对象字面量

var obj={};
3、利用构造函数创建对象

function Obj(参数a1,参数a2){
    this.属性一=参数a1;
    this.属性二=参数a2;
    this.method=function(){
        ...
    }
}
var obj1=new Obj(参数，参数)
var obj2=new Obj(参数，参数)
其中第三种方法比较消耗内存，obj1和obj2创建后会在内存中开辟两个空间，其中method方法会被创建两次，也就是在内存中会开辟两次内存，这样就大大浪费了空间，解决方法可以参照原型中添加方法，如下

function Obj(参数a1,参数a2){
    this.属性一=参数a1;
    this.属性二=参数a2;
}
Obj.prototype.method=function(){
    ...
}
var obj1=new Obj(参数，参数)
var obj2=new Obj(参数，参数)
js中每一个构造函数都有一个prototype属性，指向另一个对象，即原型对象，这个对象的所有属性和方法都会被构造函数所拥有，可以把那些不变的方法定义在prototype对象上，这样所有对象实例就可以共享这些方法。



构造函数和原型
1、每个对象都会有一个__proto__属性 ，指向构造函数的prototype原型对象
2、每个构造函数都有一个prototype属性指向原型对象，称为prototype原型对象
3、__proto__对象原型和原型对象prototype是等价的



1.offsetWidth属性可以返回对象的padding+border+width属性值之和，style.width返回值就是定义的width属性值。  
2.offsetWidth属性仅是可读属性，而style.width是可读写的。  
3.offsetWidth属性返回值是整数，而style.width的返回值是字符串，并且带有单位。  
4.style.width仅能返回以style方式定义的内部样式表的width属性值。




vue路由的底层原理

    深度优先遍历的非递归做法时采用栈；广度优先遍历的非递归做法时采用队列
    深度优先遍历是把每个分支深入到不能深入为止。具体的有先序遍历、中序遍历、后序遍历；广度优先遍历又称层序遍历，从上往下一层一层遍历


力扣11-盛最多水的容器
7.
(1)aa 123456 bb
(2)aa 12345678... bb
假设aa,bb给一定宽度，中间不到某个临界点就输出多少显示多少，超过之后用...代替
进阶：如果aa,bb不给定宽度怎么实现（提示：flex布局）

反转链表

移动端
    width 　　　　 　　　　 // 设置 viewport 的宽度，正整数/字符串 device-width
    height 　　　　　　　　 // 设置 viewport 的高度，正整数/字符串 device-height
    initial-scale  　　　 // 设置设备宽度与 viewport大小之间的缩放比例，0.0-10.0之间的正数
    maximum-scale 　　　　// 设置最大缩放系数，0.0-10.0之间的正数
    minimum-scale 　　　　// 设置最小缩放系数，0.0-10.0之间的正数
    user-scalable 　　　　// 如果设置为 no 用户将不能缩放网页，默认为 yes，yes / no

iOS10以后版本不接受meta标签，可以通过js监听手势控制来实现禁止页面缩放：
    document.addEventListener('gesturestart', function (event) {
        event.preventDefault()
    })


vue-router钩子函数和执行顺序





document.addEventListener("DOMContentLoaded", function(event) {
    console.log("DOM fully loaded and parsed");
});


onload




那如何使用createNodeIterator对页面中所有元素进行遍历输出呢？
    const body = document.getElementsByTagName('body')[0]
    const it = document.createNodeIterator(body)
    let root = it.nextNode()
    while(root) {
        console.log(root)
        root = it.nextNode()
    }



<!-- await-to-js -->


hash模式下，通过
window.addEventListener('hashChange', (e) => {
    console.log(e);   // 里面会有新旧url的信息
})



history:模式下：
history.pushState({state: 1}, '', '/ccc')
history.replaceState()

window.addEventListener('popstate', (e) => {
    console.log(e)
})

pushState不会被popstate事件监听到，需要手动刷新


构建dom树流程：
    1、浏览器获取到HTML文件，对文件进行解析，形成DOM树
    2、通过<!DOCTYPE>告知浏览器当前的html是个什么版本的页面，
    3、在<head>头部标签中的<meta>标签会有一个编码格式，和视口大小，是否能够缩放，
    4、向下继续解析就会有一个<link>标签，line一般引入的是css样式，然后进入这个链接进行一个解析，生成        styleRules,在解析过程中，并不影响DOM的渲染  
    5、DOM继续向下进行渲染，当遇到<script>标签后被阻塞执行，会进入src中的js脚本进行解析，解析完成后才会继续执行DOM渲染，
    6、将DOM树和style Rules进行合并成render Tree渲染数
    7、进入布局阶段，为每一个节点分配一个出现在屏幕的确定坐标
    8、通过CPU进行渲染绘制，将每个节点在呈现出来



source标签
    <video width="658" height="444" poster="http://www.youname.com/images/first.png" autoplay="autoplay" preload="none" controls="controls"><source src="http://www.youname.com/images/first.ogv" /><source src="http://www.youname.com/images/first.ogg" /></video>
    Source标签用于给媒体（因为audio标签同样可以包含此标签，所以这儿用媒体，而不是视频）指定多个可选择的（浏览器最终只能选一个）文件地址，且只能在媒体标签没有使用src属性时使用。
    浏览器按source标签的顺序检测标签指定的视频是否能够播放（可能是视频格式不支持，视频不存在等等），如果不能播放，换下一个。此方法多用于兼容不同的浏览器。Source标签本身不代表任何含义，不能单独出现。
    此标签包含src、type、media三个属性。
    src属性：用于指定媒体的地址，和video标签的一样。
    Type属性：用于说明src属性指定媒体的类型，帮助浏览器在获取媒体前判断是否支持此类别的媒体格式。
    Media属性：用于说明媒体在何种媒介中使用，不设置时默认值为all，表示支持所有媒介。




    使用on事件名的形式绑定事件后绑定会覆盖前面绑定的事件，也就是最后一个绑定的事件会生效；
    使用addEventListener绑定事件则不会覆盖，可同时在一个元素上绑定多个相同的事件。



nextTick为什么用微任务




vue组件是怎么挂载的：
    1、组件三种挂载方式
    自动挂载
    var app3 = new Vue({
        el: '#app-3',
        data: {
            seen: true
        }
    })

    手动挂载
    // 可以实现延迟按需挂载
    <p id="app"> {{name}} </p> 
    <button onclick="test()">挂载</button> 
    <script> 
        var obj= {name: '张三'} 
        var vm = new Vue({ 
            data: obj
        }) 
        function test() { 
            vm.$mount("#app"); 
        }


    // Vue.extend()创建没有挂载的的子类,可以使用该子累创建多个实例
    var app= Vue.extend({ 
        template: '<p>{{message}}</p>', 
        data: function () { 
            return { 
                message: 'message'
            } 
        } 
    }) 
    new app().$mount('#app') // 创建 app实例，并挂载到一个元素上




Promise怎么取消或中断：
    <!-- 1. -->
    Promise.resolve().then(() => {
        console.log('ok1')
        return new Promise(()=>{})  // 返回“pending”状态的Promise对象
    }).then(() => {
        // 后续的函数不会被调用
        console.log('ok2')
    }).catch(err => {
        console.log('err->', err)
    })


    Promise.resolve().then(() => {
        console.log('ok1')
        throw 'throw error1'
    }).then(() => {
        console.log('ok2')
    }, err => {     
        // 捕获错误
        console.log('err->', err)
    }).then(() => {   
        // 该函数将被调用
        console.log('ok3')
        throw 'throw error3'
    }).then(() => {
        // 错误捕获前的函数不会被调用
        console.log('ok4')
    }).catch(err => {
        console.log('err->', err)
    })




flex 布局原理
    任何一个容器都可以指定为 flex 布局
    当父元素设置 flex 布局之后，子元素的 float，clear 和 vertical-align 属性将失效
    当父元素设置 flex 布局之后，子元素将自动成为容器成员
    flex 布局原理：就是通过给父盒子添加 flex 属性，来控制子元素的位置和排列方式


vue的nextTick，为什么微任务处理的时候能获取到更新后的DOM:
    首先是nextTack会放在数据data修改的后面，数据一修改，DOM异步微任务就会放在微任务队列里


自我介绍
    为什么学前端
    有什么还在流程中
    为什么选择携程
    为什么选择上海
    优势是什么



有人可能会说 
    A 发出第三次握手的信息后在没有接收到 
    B 的请求就已经进入了连接状态，那如果 A 的这个确认包丢失或者滞留了怎么办？
    我们需要明白一点，完全可靠的通信协议是不存在的。在经过三次握手之后，客户端和服务端已经可以确认之前的通信状况，都收到了确认信息。所以即便再增加握手次数也不能保证后面的通信完全可靠，所以是没有必要的。