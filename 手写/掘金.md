-1 == true  错误    小于等于0都会变成false

![] == ''    对



```js
var name = 'jerry';   
var obj = {  
    name : 'tom',  
    sayName(){  
        return function(){  
            console.log(this.name);  
        };
    }   
};
obj.sayName()(); // jerry



// var name = 'jerry';
var obj = {
    name: 'tom',
    sayName() {
        var name = 'alan';
        console.log(this.name);
    }
};
var sayName = obj.sayName;
sayName(); // '' // jerry




function fun(a,b) {
    console.log(b)
    return {
        fun: function(c) {
            return fun(c,a);
        }
    };
}
var d = fun(0); // undefined
d.fun(1); // 2 0
d.fun(2); // 2 0
d.fun(3); // 2 0

var d1 = fun(0).fun(1).fun(2).fun(3);
// 2 undefined 2 0
// 2 1
// 2 2

var d2 = fun(0).fun(1); d2.fun(2);
// 2 undefined
// 2 0
// 2 1
// 2 1

d2.fun(3); // {fun: ƒ}
```

```


深度遍历与广度
async await
js设计模式

鼠标事件坐标
offsetX, clientX, pageX, screenX

元素视图尺寸
offsetLeft, offsetTop: 当前元素到定位父节点的top方向上的距离
offsetWidth: 获取的值为    当前元素width + 左右padding + 左右border - width
clientWidth: 获取的值为    当前元素宽度 + 左右的padding
scrollWidth: 获取当前元素内容真实的宽度， 内容不超过盒子时为盒子的clientWidth

window视图的尺寸
innerWidth: 浏览器窗口可视区宽度 （不包括浏览器控制台，菜单栏，工具栏）


__proto__   protype
原型，原型链

所有对象都有一个属性 __proto__ 指向一个对象，也就是原型   对象
每个对象的原型都可以通过 constructor 找到构造函数，构造函数也可以通过 prototype 找到原型
所有函数都可以通过 __proto__ 找到 Function 对象
所有对象都可以通过 __proto__ 找到 Object 对象
对象之间通过 __proto__ 连接起来，这样称之为原型链。当前对象上不存在的属性可以通过原型链一层层往上查找，直到顶层 Object 对象，再往上就是 null 了



深拷贝

垃圾回收    /

call,apply,bind的手写

通过遍历data中的数据，将数据代理到this上      /



diff

postMessage实现跨域
   语法：window.postMessage(msg,targetOrigin)
    message：要发送的消息，部分浏览器只能处理字符串参数，所以我们在传递参数的时候需要使用JSON.stringify()方法对对象参数序列化
    targetOrigin：“目标域“，包括：协议、主机名、端口号。若指定为”*“，则表示可以传递给任意窗口，指定为”/“，则表示和当前窗口的同源窗口。

    获取postMessage传来的消息：为页面添加onmessage事件
    window.addEventListener('message',function(e) {
        
    }
    onmessage事件接受一个参数e,它是一个event对象。
    e的几个重要属性：
      1、data：postMessage传递过来的msg
      2、发送消息的窗口对象
      3、origin：发送消息窗口的源（协议+主机+端口号）



点击劫持里面的iframe是如何内嵌到第三方网页上实现点击劫持的
    攻击者使用一个或多个透明的 iframe 覆盖在一个正常的网页上，当用户在不知情的情况下点击透明的 iframe 页面时，用户的操作已经被劫持到攻击者事先设计好的恶意按钮或链接上。攻击者既可以通过点击劫持设计一个独立的恶意网站，执行钓鱼攻击等；也可以与 XSS 和 CSRF 攻击相结合，突破传统的防御措施，提升漏洞的危害程度

    通过XSS漏洞弹出弹框，诱导用户点击触发点击劫持，浏览器执行恶意的js代码，故此将会产生极大的危害

点击劫持的防御
    X-FRAME-OPTIONS机制， 
        DENY：浏览器会拒绝当前页面加载任何frame页面
        SAMEORIGIN：frame页面的地址只能为同源域名下的页面
        ALLOW-FROM origin：允许frame加载的页面地址



csrf攻击B站如何获取A站的cookie信息的，原理

vue双向绑定的原理，如何达到视图更新的

data不发生更新时，computed还会进行缓存操作吗？还会执行吗？

服务端渲染

隐藏盒子的几种方式

高度塌陷

实现一个页面加载进度条

css reset 和 Normalize.css 有什么区别

css hask：
    不同的浏览器对应不同的内核，它们对css的解析是不一样的，这样就会导致在不同的浏览器中呈现出不一致的效果，为了获得统一（或者为了给不同的浏览添加不同效果），就需要针对不同的浏览器或者不同的版本写特定的css样式，这就叫css hack

    1. css属性前缀法   例如 IE6能识别下划线"_"和星号" * "，IE7能识别星号" * "，但不能识别下划线"_"，IE6~IE10都认识"\9"，但firefox前述三个都不能认识。

    2.  css选择器前缀法     例如 IE6能识别*html .class{}，IE7能识别*+html .class{}或者*:first-child+html .class{}。

    3. IE条件注释法   针对所有IE(注：IE10+已经不再支持条件注释)： IE浏览器显示的内容 ，针对IE6及以下版本： 。这类Hack不仅对CSS生效，对写在判断语句里面的所有代码都会生效。


### 伪类和伪元素的区别是什么？
概念上的区别：
- 伪类表示一种状态
- 伪元素是真的有元素。比如 ::after 是真的有元素，可以在页面上显示内容。
使用上的区别：
- 伪类：使用单冒号
- 伪元素：使用双冒号



```
![image-20220228090140367](%E6%8E%98%E9%87%91%E9%9D%A2%E7%BB%8F.assets/image-20220228090140367.png)




vue3比vue2快在哪？
    Diff算法的优化：
        Vue2 中的 虚拟DOM对比采用全量对比策略，这样的话每次渲染也就把静态dom节点做对比了。vue3中通过diff算法对比虚拟dom的时候，只会比较有动态绑定数据变化的节点，也就是有patch flag标记的。
    静态提升：
        vue2中无论节点有没有动态绑定数据，都会在render函数执行的时候重新渲染。静态的节点被提升到渲染函数外部，缓存起来，然后只会在首次的时候执行一下节点创建函数，以后每次渲染都拿外面的那个变量就行了;
    事件监听缓存：
        Vue2版本中,事件是被当做一种动态属性来监听的，但是事件监听函数，基本上是不会动态改变的；所以再进行监听是完全没有必要的。渲染函数渲染出来的对象，不再具有动态属性的标志,不是动态的，自然也不会生成监听了。
    tree-shaking
        需要什么就 import 什么，而不是每个组件都有props,
    vite
    ts
    proxy替换了之前的defineProterty


get和post的区别:
    1、url可见性：
        get，参数url可见；
        post，url参数不可见
    2、数据传输上：get，通过拼接url进行传递参数; post，通过body体传输参数;
    4、后退页面的反应   :post请求页面后退时，会重新提交请求
    3. get一般传输数据大小不超过2k-4k（根据浏览器不同，限制不一样，但相差不大）post请求传输数据的大小可以无限大。
    7、数据包
        GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。


object.defineProperty
const newObj = new Proxy(obj, {
    get: function(target, key, receiver) {
        console.log(`getting ${key}!`);
        return Reflect.get(target, key, receiver); // Reflect.get 和 Reflect.set 可以理解为类继承里的super，即调用原来的方法
    },
    set: function(target, key, value, receiver) {
        console.log(target, key, value, receiver, '对象劫持');
        if (key === "text") {
            inp.value = value;
            title.innerHTML = value;
        }
        return Reflect.set(target, key, value, receiver);
    }
});


Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与proxy handlers (en-US)的方法相同。Reflect不是一个函数对象，因此它是不可构造的。




vue数据变化UI不刷新
    使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上：
    setOptionVal: function (index, val) {
        let tempVal = this.SubjectListData[index]
        tempVal.optionIdStringResult = val
        this.$set(this.SubjectListData, index, tempVal)
    }



数据库外连接，内连接区别
    inner join  on ：对于左表的每一条记录和右表作乘积，如果满足on条件则加入结果集，最终的记录数>=0
    left    join  on ：对于左表的每一条记录和右表作乘积，如果不存在满足on条件的记录，则添加一条记录（需要返回的右表列以null表示），最终的记录数>=左表的记录数
    right  join on ： 对于右表的每一条记录和左表作乘积，如果不存在满足on条件的记录，则添加一条记录（需要返回的左表列以null表示），最终的记录数>=右表的记录数




echarts原理
    1、ECharts 是一个轻量级的 javascript 图形库，纯 js 实现，MVC 封装，数据驱动。
    2、Svg 和 Canvas 是两个可以选择的类库之一，其中 svg 交互性更好，性能较弱，不适用于移动端，在绘制数万个点时会崩溃。而 canvas 的渲染速度和性能更好，echarts 在 canvas 上构建一层 MVC层，使得它可以像 svg 一样交互。
    3、ECharts 的特点：重要性和优先级依次递减，设计效果直观、生动，能够交互，可个性化定制。

    4、ECharts 总体结构是基于 MVC 架构的，各部分的主要作用是：
    Storage(M)：模型层，实现图形数据的CURD（增删改查）管理；
    Painter(V)：  视图层，实现canvas 元素的生命周期管理，即：视图渲染、更新控制、绘图；
    Handler(C)：控制层，事件交互处理，实现完整的dom事件模拟封装。

    Storage 是一个类似数据的仓库，提供各种数据的读、写、改、删等操作。Painter 持有 Storage 对象，即：Painter 读取 Storage 进行绘图。Handler持有了Storage 对象和 Painter 对象，控制层对模型层有CURD关系，即：Handler 通过访问 Storage 对象提供的数据增删改查操作，实现事件交互处理所需的数据部分；控制层与视图层存在 call 关系，即：Handler 通过访问 Painter 对象提供的视图操作，实现事件交互处理的视图部分




vuex的单向数据流
    单向数据流指只能从一个方向来修改状态。多个组件会共享状态时，共享状态和组件间（兄弟组件）通信变的不容易。我们把共享状态抽取出来。
    组件中触发 Action，Action 提交 Mutations，Mutations 修改 State。 组件根据 State 或 Getters 来渲染页面。
    只有通过mutations来修改state


canvas与svg
    https://www.cnblogs.com/yanghuiting/p/10902001.html



hr面：
1.自我介绍
2.想要的工作性质
3.优点缺点，缺点怎么提高
4.怎么学习的，为什么走前端
5.这段时间的收获及成长
6 .还有没有其他的面试
7.如果bat都发offer,怎么选
8.最近看什么书
9.有什么想问的



web移动端安卓和ios的一些兼容问题:
    https://www.cnblogs.com/sisxxw/p/12502773.html



option请求中是否见到过
复杂跨域请求，首先会发送一个options请求来决定真正的请求是否足够安全。
那么如果区分简单请求以及复杂请求就比较关键了，下面是几个关键的点：
method
    GET
    POST
    HEAD
    headers
Accept
    Accept-Language
    Content-Language
    Content-Type
其中 content-type 值只包括
    application/x-www-form-urlencoded
    multipart/form-data
    text/plain



为什么 CORS 需要在跨域请求前进行预校验 (Preflight)
    预检验请求是一个不携带任何具体参数的 OPTIONS 请求
    采用 CORS 的服务器会正确的根据请求头来判断是否接受该跨域请求，并返回相应的响应告知浏览器
    未采用的服务器接受到请求也会正常处理
    但是返回的响应中不会正确的包含 Access-Control-Allow-* 等响应头
    浏览器接收到预检验请求的响应后会根据响应头来判断是否支持跨域
    只有当响应头满足 CORS 的相关设置才会继续发送正式的跨域请求

    在实际调用接口之前，会首先发出一个options请求，检测服务端是否支持真实的请求进行跨域的请求。真实请求在options请求中，通过request-header将 Access-Control-Request-Headers与Access-Control-Request-Method发送给后台，另外浏览器会自行加上一个Origin请求地址。服务端在接收到预检请求后，根据资源权限配置，在response-header头部加入access-control-allow-headers（允许跨域请求的请求头）、access-control-allow-methods（允许跨域请求的请求方式）、access-control-allow-origin（允许跨域请求的域）。另外，服务端还可以通过Access-Control-Max-Age来设置一定时间内无须再进行预检请求，直接用之前的预检请求的协商结果即可。浏览器再根据服务端返回的信息，进行决定是否再进行真实的跨域请求。
    
    只要是带自定义header的跨域请求，在发送真实请求前都会先发送OPTIONS请求，浏览器根据OPTIONS请求返回的结果来决定是否继续发送真实的请求进行跨域资源访问。所以复杂请求肯定会两次请求服务端。

options请求如何避免:
    1：使用代理，避开跨域。
    2：将复杂跨域请求更改为简单跨域请求。
    3：不使用带自定义配置的header头部。



CommonJS.js
es6.js



vue的loader
    简单的说，他就是基于webpack的一个的loader，解析和转换 .vue 文件，提取出其中的逻辑代码 script、样式代码 style、以及 HTML 模版 template，再分别把它们交给对应的 Loader 去处理，核心的作用，就是提取，划重点。

    selector–将.vue文件解析拆分成一个parts对象，其中分别包含style、script、template
    style-compiler–解析style部分
    template-compiler 解析template部分
    babel-loader-- 解析script部分，并转换为浏览器能识别的普通js
    
    允许为 Vue 组件的每个部分使用其它的 webpack loader
    使用 webpack loader 将 <style> 和 <template> 中引用的资源当作模块依赖来处理
    
    至于什么是webpack的loader，其实就是用来打包、转译js或者css文件，简单的说就是把你写的代码转换成浏览器能识别的，还有一些打包、压缩的功能等。



vue请求数据放在
    建议放在created里
    created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。
    mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。
    如果在mounted钩子函数中请求数据可能导致页面闪屏问题
    其实就是加载时机问题，放在created里会比mounted触发早一点，如果在页面挂载完之前请求完成的话就不会看到闪屏了



rem根字体大小设置
    <!DOCTYPE html>
    <html>
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta charset="utf-8">
        <title></title>
        <script>
            var c=()=>{
                let w = document.documentElement.clientWidth; /*获取设备的宽度*/
                let n = (20 * (w / 320) > 40 ? 40 + "px": (20*(w/320) + "px"));
                // console.log(n)
                // 注意这里
                document.documentElement.style.fontSize=n
            }
            window.addEventListener("load",c)
            window.addEventListener("resize", c)
        </script>
        <style>
            html{
                font-size: 200px;
            }
            div{
                font-size: 2rem;
            }
        </style>
    </head>
    <body>
        <div>123</div>
    </body>
    </html>



websocket设置
    事件：
    server.on('open', handleOpen);
    server.on('close', handleClose);
    server.on('error', handleError);
    server.on('connection', handleConnection);
    所有的连接者:
    server.clients
    连接者.send()即可

    有信息来的话就会触发on,
    ws.on('message', handleMessage);
    
    function handleMessage (msg) {
        const msg01 = JSON.parse(msg.toString())
        msg01.user = AES.aesDecrypt(msg01.user)
        server.clients.forEach((c) => {
            c.send(JSON.stringify(msg01));
        })
    }



2、组合式 API
    Options API 的特点是在对应的属性中编写对应的功能模块
    比如：在 methods 中定义方法，在 computed 中定义计算属性
    缺点是：
    实现某一个功能时，该功能对应的代码逻辑会被 拆分 到各个属性中
    然而，当我们的组件变得更大、更复杂的时候，我们需要实现的功能也就越多
    每一个功能对应的代码逻辑都被拆的很分散，代码碎片化
    这是 不方便 我们的去 理解和维护 这个组件的
    因此，在 Vue 组件中，我们可以在 setup 中使用组合式 API，来解决上述问题
    注意：在 setup 中，我们应该避免使用 this




单文件组件与非单文件组件


// 监听hash变化
    // 每次点击路由，current都会变化，但是render却不会再次执行
    window.addEventListener('hashchange', () => {
        this.current = window.location.hash.slice(1)  // 截取到#号后面的部分
    })







rpx的原理：
    小程序编译后，rpx会做一次px换算。换算是以375个物理像素为基准，也就是在一个宽度为375物理像素的屏幕下，1rpx = 1px。

    举个例子：iPhone6屏幕宽度为375px，共750个物理像素，那么1rpx = 375 / 750 px = 0.5px。


TCP 怎么保证传输的可靠性？如果ACK 1 2 3 4 5中 4 不见了怎么办？
    队头阻塞，面试官：一定会阻塞吗？
    超时重传，面试官：还有吗？等的话要等多久？


浏览器URL的解析全过程，越详细越好

webpack配置反向代理
    devServer: {
        contentBase: path.resolve(__dirname, "../dev"),
        compress: true,
        port: 9000,  //本身的端口号
        host: 'localhost',
        proxy: {
            '/api': {
                target: 'http://localhost:3000',  //代理到的地址
                changeOrigin: true
            }
        }
    }

nginx配置反向代理：
    ![image-20220306133705095](%E6%8E%98%E9%87%91.assets/image-20220306133705095.png)
    在serve中配置：
        server_name: 
            配置为nginx的地址
        listen:
            配置端口

        location字段  / ：
            配置proxy_pass: 为node中的路径





超时重传的时间：
    在Linux中（BSD Unix和Windows下也是这样）超时以500ms为一个单位进行控制，每次判定超时重发的超时时间都是500ms的整数倍。重发一次后，仍未响应，那么等待2*500ms的时间后，再次重传。等待4*500ms的时间继续重传。以一个指数的形式增长。累计到一定的重传次数，TCP就认为网络或者对端出现异常，强制关闭连接。


tcp的拥塞控制
    TCP传输的过程中，发送端如果刚开始就发送大量的数据，网络可能在开始的时候就很拥堵。
    所以TCP引入了慢启动的机制，在开始发送数据时，先发送少量的数据探路。这时候就引入一个叫做拥塞窗口。发送刚开始定义拥塞窗口为 1，每次收到ACK应答，拥塞窗口加 1。在发送数据之前，首先将拥塞窗口与接收端反馈的窗口大小比对，取较小的值作为实际发送的窗口。

    拥塞窗口的增长是指数级别的。慢启动的机制只是说明在开始的时候发送的少，发送的慢，但是增长的速度是非常快的。为了控制拥塞窗口的增长，设置一个拥塞窗口的阈值，当拥塞窗口大小超过阈值时，不能再按照指数来增长，而是线性的增长。在慢启动开始的时候，慢启动的阈值等于窗口的最大值，一旦造成网络拥塞，发生超时重传时，慢启动的阈值会为原来的一半（这里的原来指的是发生网络拥塞时拥塞窗口的大小），同时拥塞窗口重置为 1。

确认应答与序列号
    序列号：TCP传输时将每个字节的数据都进行了编号，这就是序列号。
    确认应答：TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文。这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。




先来分析一下 webpack Plugin 的工作原理

    读取配置的过程中会先执行 new HelloPlugin(options) 初始化一个 HelloPlugin 获得其实例。
    初始化 compiler 对象后调用 HelloPlugin.apply(compiler) 给插件实例传入 compiler 对象。
    插件实例在获取到 compiler 对象后，就可以通过compiler.plugin(事件名称, 回调函数) 监听到 Webpack 广播出来的事件。
    并且可以通过 compiler 对象去操作 Webpack。


![WebPack 编译流程图](https://segmentfault.com/img/remote/1460000023016350)




怎么能不使用缓存：
    cache-control:  no-store;


js与css加载顺序



浏览器缓存的问题
<html lang="en">
    <head>
        <title>test cache</title>
        <link rel="stylesheet" href="./index.css">
        <link rel="stylesheet" href="./index.css">
        <script src="./index.js"></script>
        <script src="./index.js"></script>
        <img src="./index.png">
        <img src="./index.png">
    </head>
<body>
    hello
</body>
</html>



1.这个index.html文件中，不设置任何缓存相关的策略，每种静态资源会请求几次？
2.如果给存放三种资源的服务器响应头加上Cache-Control:no-cache，这三种资源又各自会被请求几次？
3.那如果把no-cache改成no-store，会请求几次？
4.把no-cache改成max-age，又会有什么变化？
我们先不着急看答案，先看看原理分析，一步步分析出答案。

1.不设置任何缓存策略的情况下，请求只有一次。这是浏览器本身做的优化，在解析html文件时，如果监测到两个资源的地址相同，那么只会请求一次。
2.设置Cache-Control是no-cache，也是相同资源只有一次请求，no-cache并不是一定没有缓存，而是无法命中强缓存，但是还可以继续查找是否能命中协商缓存。
3.改成no-store之后，请求就有两次了，这也正好验证了no-store和no-cache的区别，no-store是绝对不走缓存，每次请求都去服务器请求新资源。
4.改成max-age，这个值设置为一年，请求也只会走一次，而且在浏览器当前TAB刷新页面，会发现Network中Size一栏不是具体的文件大小，而是from cache，这是因为已经命中了浏览器的缓存策略，所以再次缓存时，是去缓存中取资源。


1.不经常变化的资源，比如打包出来的第三方库JS，给这类资源设置一个较长的缓存周期，比如一年

Cache-Control: max-age=31536000
设置了这个字段后，就命中了强缓存策略，那么如果在一年内我们修改了这个文件，如何让用户端能够强制请求最新资源呢？

答案就是哈希，在webpack打包时给这类资源加上contentHash，一旦资源内容有更新，打包出来的资源的哈希值也会更新，用户端去加载资源时，去缓存中找不到符合这个哈希值版本的资源文件，自然会去服务端请求最新的资源。

2.经常变化的资源，比如模板文件html，这类文件的请求URL通常不会变化，但是内容会经常变化，因为每次项目更新，插入到html文件中的js或者css可能有更新。

Cache-Control: no-cache
协商缓存响应头设置成no-cache，配合协商缓存一起使用，浏览器每次都会去服务器核对资源有没有更新，如果资源没有更新，那么会返回一个304的状态码，不会返回真实的响应体，这种形式相比于命中强缓存，虽然无法节省那次网络请求，但是如果命中了协商缓存，会节省返回的响应体体积，也算是性能优化的一种。




transform 和 transition



点击后让元素飞入指定位置


document.documentElement.getBoundingClientRect().top
document.documentElement.scrollHeight
document.documentElement.clientHeight





